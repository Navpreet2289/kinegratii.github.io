<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[圈复杂度和McCabe]]></title>
    <url>%2F2018%2F04%2F08%2Fcyclomatic-complexity-and-mccabe%2F</url>
    <content type="text"><![CDATA[圈复杂度（Cyclomatic Complexity）是衡量计算机程序复杂程度的一种措施。它根据程序从开始到结束的线性独立路径的数量计算得来的。在 Python 中可以使用 mccabe 包测量程序的圈复杂度。 1 圈复杂度对于没有任何分支的代码，它的圈复杂度为 1 ，意味着代码只有一条路径。例如下面的函数： 123def add(a, b): return a + b 对于有一条分支的代码，它的圈复杂度为 2 ，比如下面递归计算阶乘的代码： 12345def factorial(n): if n == 0: return 1 else: return n * factorial(n-1) 在 1976 年， Thomas J. McCabe 开发了使用有向图计算复杂的算法。为了得到这个指标，程序控制流程图可以画成一个有向图，其中： 节点表示一个程序块 边表示从一个程序块到另一个程序块的控制流 根据程序的控制图，McCabe 复杂度可以表示为 1M = E - N + 2P 其中： E：边的数量 N：节点的数量 P：连接组件的数量 2 McCabe的使用在 Python 中可以使用 McCabe 包测量程序的圈复杂度。它可以当作一个独立的模块，也可以当作程序的一个插件。可以使用 pip 安装模块 1pip install mccabe 2.1 作为命令行使用和 unittest 、flake8 等工具一样。 1234567$ python -m mccabe --min 5 mccabe.py("185:1: 'PathGraphingAstVisitor.visitIf'", 5)("71:1: 'PathGraph.to_dot'", 5)("245:1: 'McCabeChecker.run'", 5)("283:1: 'main'", 7)("203:1: 'PathGraphingAstVisitor.visitTryExcept'", 5)("257:1: 'get_code_complexity'", 5) 2.2 作为 flake8 插件当 flake8 版本在 2.0 以上和 McCabe 已经安装的情况下，该插件可用。 12$ flake8 --version2.0 (pep8: 1.4.2, pyflakes: 0.6.1, mccabe: 0.2) 在命令中使用 --max-complexity 选项即可。 123$ flake8 --max-complexity 10 coolproject...coolproject/mod.py:1204:1: C901 &apos;CoolFactory.prepare&apos; is too complex (14) 根据 McCabe 圈复杂度大于 10 ，就认为是 too complex ，需要进行重构以降低复杂度。 3 程序控制图3.1 生成程序控制图以上述 factorial 函数代码为例子，将其保存为一个 factorial.py 文件中，如下： 1234567# coding=utf8def factorial(n): if n == 0: return 1 else: return n * factorial(n-1) 第一步 使用 python -m mccabe factorial.py -d 输出 dot 文本图形描述语言的有向图。 1234567891011121314graph &#123;subgraph &#123;node [shape=circle,label=&quot;If 4&quot;] 2187726207240;node [shape=circle,label=&quot;3:0: &apos;factorial&apos;&quot;] 2187726207016;node [shape=circle,label=&quot;Stmt 5&quot;] 2187726207408;node [shape=point,label=&quot;&quot;] 2187726207296;node [shape=circle,label=&quot;Stmt 7&quot;] 2187726207520;2187726207240 -- 2187726207408;2187726207240 -- 2187726207520;2187726207016 -- 2187726207240;2187726207408 -- 2187726207296;2187726207520 -- 2187726207296;&#125;&#125; 第二步，Graphviz渲染图片 Graphviz 是 AT&amp;T Labs Research开发的图形绘制工具软件.它使用一个特定的DSL(领域特定语言): dot作为脚本语言，然后使用布局引擎来解析此脚本，并完成自动布局。graphviz提供丰富的导出格式，如常用的图片格式，SVG，PDF格式等。 打开 Graphviz 编辑器，将上述文档保存为 factorial.gv 文档，生成程序控制图。 第三步，计算 McCabe 复杂度 根据公式，复杂度： M = 5 - 4 + 2 x 1 = 2 4 降低复杂度使用字典替代复杂的 if-else 分支代码是 Python 中降低复杂度一个有效的方法。 比如可以将下面的分支代码： 12345678def f(x): if x == 'a': return 1 elif x == 'b': return 2 else: return 9 改为下面的字典映射代码 123456def f(x): return &#123; 'a': 1, 'b': 2 &#125;.get(x, 9) 复杂度也从 3 降低到 1 。 5 参考资料 Software Architecture with Python The Architecture of Open Source Applications]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyecharts：改善渲染效率]]></title>
    <url>%2F2018%2F03%2F03%2Fmake-chart-render-faster%2F</url>
    <content type="text"><![CDATA[本文已收录于 《pyecharts 开发专辑》 。 本文所述的基于特性 v0.3.3 版本，预计于 v0.3.4 / v0.4.0 加入。 问题一直以来， pyecharts 都是推荐使用下面的方式多次渲染图表。 代码 1 123456789from pyecharts import Bar, Linebar = Bar("直方图示例")bar.add()bar.render(path='bar.html')line = Line("测试图表")line.add()bar.render(path='line.html') 但历经多次版本迭代后，该代码效率有所降低。 chart.render 函数调用了 engine.render 函数，该函数源码如下： 代码 2 123456789def render(template_file, notebook=False, **context): config = conf.CURRENT_CONFIG echarts_env = EchartsEnvironment( pyecharts_config=config, loader=FileSystemLoader( [config.echarts_template_dir, conf.DEFAULT_TEMPLATE_DIR]) ) template = echarts_env.get_template(template_file) return template.render(**context) 可以看出，每调用一次都会重新创建一个 EchartsEnvironment 实例，问题在于 EchartsEnvironment 引擎对象并不是一个简单的数据存储型对象，每次对象的创建都需要花费大量时间，特别是寻找和编译模板文件，而且在对象创建后就无法修改。 在上述使用示例中，二者的所使用的引擎对象配置是一样的但需要创建两次，无形中降低了执行效率。 使用底层API基于第一节所述的问题，改成只创建一次引擎对象，基本代码如下： 代码 3 1234567891011121314151617181920from pyecharts import Bar, Linefrom pyecharts.conf import PyEchartsConfigfrom pyecharts.engine import EchartsEnvironmentfrom pyecharts.utils import write_utf8_html_filebar = Bar("直方图示例")bar.add()line = Line("测试图表")line.add()config = PyEchartsConfig()env = EchartsEnvironment(pyecharts_config=config)tpl = env.get_template('simple_chart.html')html = tpl.render(chart=bar)write_utf8_html_file('bar.html', html)html = tpl.render(chart=line)write_utf8_html_file('line.html', html) 显然和第一节相比，该代码使用了更为底层的 API，虽然符合一般的渲染过程 （参见 文档-图表api），但是使用者需要了解一些更为底层的内部逻辑，方便性有所下降。 比如使用了write_utf8_html_file 这个工具方法 需要使用者显式指定 simple_chart.html 模板文件，之前是作为默认参数 改进方案（一）第一种改进是基于第一份代码，直接使用 “Lazy Object” 方式，实现只有一个 EchartsEnvironment 的单例对象，关于具体细节可以查看之前的 PR 240 。 改进方案（二）第二种方案是基于第二份代码，并对此作一些封装。实现要点在于： EchartsEnvironment 增加 render_chart 方法，参数与 现有的 chart.render 基本上相同 Chart.render 直接调用 EchartsEnvironment.render_chart 方法 原有的 engine.render 和 engine.render_notebook 合并，等到 notebook 整合后直接移除，实际上已经向下移到 EchartsEnvironment 类了 实例代码 代码 4 12345678910111213141516171819202122232425262728293031323334class EchartsEnvironment(BaseEnvironment): """ Built-in jinja2 template engine for pyecharts """ def __init__(self, pyecharts_config=None, *args, **kwargs): pyecharts_config = pyecharts_config or conf.PyEchartsConfig() loader = kwargs.pop('loader', None) if loader is None: loader = FileSystemLoader(pyecharts_config.echarts_template_dir) super(EchartsEnvironment, self).__init__( pyecharts_config=pyecharts_config, keep_trailing_newline=True, trim_blocks=True, lstrip_blocks=True, loader=loader, *args, **kwargs) def render_chart_to_file( self, chart, object_name='chart', path='render.html', template_name='simple_chart.html', extra_context=None ): context = &#123;object_name: chart&#125; context.update(extra_context or &#123;&#125;) tpl = self.get_template(template_name) html = tpl.render(**context) write_utf8_html_file(path, html) def render_chart_to_notebook(self): pass 单个图表实现方式，Base.render 直接调用 env.render_chart_to_file 函数。 代码 5 12345678910111213141516171819class Base: def render(self, path='render.html', template_name='simple_chart.html', object_name='chart', extra_context=None): config = conf.CURRENT_CONFIG echarts_env = EchartsEnvironment( pyecharts_config=config, loader=FileSystemLoader( [config.echarts_template_dir, conf.DEFAULT_TEMPLATE_DIR]) ) echarts_env.render_chart( chart=self, object_name=object_name, path=path, template_name=template_name, extra_context=extra_context ) 多次渲染图表可以使用以下的代码，变得更为简洁，明朗。 代码 6 12345678910111213141516from pyecharts import Bar, Linefrom pyecharts.conf import PyEchartsConfigfrom pyecharts.engine import EchartsEnvironmentfrom pyecharts.utils import write_utf8_html_filebar = Bar("直方图示例")bar.add()line = Line("测试图表")line.add()config = PyEchartsConfig()env = EchartsEnvironment(pyecharts_config=config)env.render_chart_to_file(bar, path='bar.html')env.render_chart_to_file(line, path='line.html') 这种方案最大的优点，将 render 渲染这个操作变成了是引擎对象提供的方法，这一点符合面向对象的实际情形，也和 jinja2 ，django 等模板系统保持一致，而原来的 chart.render 就变成了一个 shortcut 方法，继续可以使用。 与 Notebook 渲染的整合pyecharts 的 issue #412 也提出了关于 Notebook 使用场景下，引擎对象对此创建的问题，和其他一些问题。 主要解决方案如下： 第一步，整合模板，将所有的模板代码使用 notebook.html 存储，至于其中一些代码片段，借助已经实现的模板函数，将一些数据逻辑处理移到模板函数内执行，这样就能和本地渲染共用一些代码。 第二步，减少模板文件的 context 字典，将图表变量（chart 或 page）使用固定参数，其他使用 **kwargs 方式传入。例外的是 require_config ，该内部实现相对比较复杂，暂时没有进行改动，只是传入形式由：**require_config 改为更加明确的 config_items=config_items,libraries=libraries 。 为了提供方面，engine 提供了一个创建基本引擎对象的方法，纯 Python 和 notebook 两种场景下均可使用。 代码 7 123456789101112def create_default_environment(): """ Create environment object with pyecharts default single PyEchartsConfig. :return: """ config = conf.CURRENT_CONFIG echarts_env = EchartsEnvironment( pyecharts_config=config, loader=FileSystemLoader( [config.echarts_template_dir, conf.DEFAULT_TEMPLATE_DIR]) ) return echarts_env 针对上述，继续使用 create_default_environment 优化为以下的代码： 代码 8 12345678910111213from pyecharts import Bar, Linefrom pyecharts.engine import create_default_environmentbar = Bar("直方图示例")bar.add()line = Line("测试图表")line.add()env = create_default_environment()env.render_chart_to_file(bar, path='bar.html')env.render_chart_to_file(line, path='line.html') 改进过程：代码1/ 代码2 -&gt; 代码6 -&gt; 代码8 总体架构 备注： 绿色表示 纯 Python 的调用路径；蓝色表示 Jupyter Notekook 的调用路径。 经过整合后， 第一，无论是 纯 Python 和 Jupyter Notekook 两个使用场景在底层均可使用相同的模板代码。 第二，这个模板代码由两部分组成。 1) 代码小片段使用 Python 代码表示，使用 string.formmat 函数格式化和渲染。比如 12345678LINK_SCRIPT_FORMATTER = '&lt;script type="text/javascript" src="&#123;&#125;"&gt;&lt;/script&gt;'EMBED_SCRIPT_FORMATTER = '&lt;script type="text/javascript"&gt;\n&#123;&#125;\n&lt;/script&gt;'CHART_DIV_FORMATTER = '&lt;div id="&#123;chart_id&#125;" style="width:&#123;width&#125;;height:&#123;height&#125;;"&gt;&lt;/div&gt;' # flake8: noqaCHART_CONFIG_FORMATTER = """var myChart_&#123;chart_id&#125; = echarts.init(document.getElementById('&#123;chart_id&#125;', null, &#123;&#123;renderer: '&#123;renderer&#125;'&#125;&#125;));var option_&#123;chart_id&#125; = &#123;options&#125;;myChart_&#123;chart_id&#125;.setOption(option_&#123;chart_id&#125;);""" 上述代码由模板函数调用，并组成完整可用的 html 页面， 2) 其他完整的页面，使用 html 页面存储代码，支持用户自定义，使用 jinja2.Environment 渲染和传入数据。 更新日志面向开发者 整合模板存储，html 文件只保留完整可用的模板代码，小片段代码全部使用 Python 代码实现，参见 engine 模块 移除 engine.render 和 engine.render_notebook 方法 Notebook 相关测试案例移到新模块 面向使用者 引擎类增加快捷的渲染方法 render_chart_to_file 增加创建默认引擎类方法 pyecharts.engine.create_default_environment 重构渲染内部实现，改善效率 修正图表 width/height 在 Noteboo 渲染的 bug 总结如果多次渲染图表，应当使用更为底层的 render_chart 方法， 这是需要坚持的一点。使用 chart.render 方式依旧无法解决多次创建引擎对象的问题，关于这一点之前已有多次讨论。]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-echarts v0.3 系列发布日志]]></title>
    <url>%2F2018%2F02%2F25%2Fdjango-echarts-030-release-note%2F</url>
    <content type="text"><![CDATA[本文已收录于 《pyecharts 开发专辑》 。 v0.3.2 发布日志django-echarts v0.3.2 于 2018 年 3 月 13 日正式发布。版本日志为： 移除 Django 的显示依赖 移除对 numpy.Array 的默认json编码 v0.3.1 发布日志django-echarts v0.3.1 于 2018 年 3 月 8 日正式发布。版本日志为： 恢复对 Django 1.11 LTS 的支持 改善 fetch 模块调用方式，ifetch_multiple 函数的关键字参数不再需要重复指定默认值 fetch 模块函数支持自定义 getter 参数 ECharts 默认版本更新至v4.0.4 支持 ECharts 4.0 SVG渲染器的配置 1 fetch 模块改进v0.3.1 基于 PEP 3102 调整了 fetch 模块所有函数的定义形式。由 12def ifetch_multiple(iterable, defaults, getter, *keys): pass 更改为 12def ifetch_multiple(iterable, *keys, defaults=None, getter=None): pass 其中 default / defaults / getter 三个可选参数均要求以关键字形式传入。 之前无论是否使用自己的 defaults 均必须传入以符合位置参数的要求，现在无需这种做法。 之前： 1ifetch_multiple(DICT_LIST_DATA, &#123;&#125;, None, 'name', 'age') 现在：1ifetch_multiple(DICT_LIST_DATA, 'name', 'age') 2 增加自定义 getter 回调函数一个简单的例子： 12345678910class MockItem: def __init__(self, x, y, z): self._data = &#123;'x': x, 'y': y, 'z': z&#125; def get(self, key): return self._data.get(key)my_getter = lambda item, key: item.get(key)data_list = [MockItem(1, 2, 3), MockItem(4, 5, 6), MockItem(7, 8, 9)]xs, ys, zs = fetch(data_list, 'x', 'y', 'z', getter=my_getter) getter 必须是一个回调函数，函数符合以下的要求： 必须含有名称为 item 和 key 的两个参数 item 表示单个实体类对象；key 表示索引、属性、键值名称 3 支持 ECharts SVG 配置django-echarts 新增了一个名为 renderer 的项目配置项，可选值包括 &#39;canvas&#39; 和 &#39;svg&#39; 。 django-echarts 按照以下顺序选择渲染方式： 图表属性 Chart.renderer 项目配置的 DJANGO_ECHARTS[‘renderer’] 的设置 django-echarts 默认使用 canvas 渲染器，可以通过以下方式更改为 svg 渲染。 1234DJANGO_ECHARTS = &#123; 'echarts_version':'4.0.4', 'renderer': 'svg'&#125; 注意的是只有 echarts_version 大于 4 时，才可以使用 svg 渲染。django-echarts 并不会强制检查这一点，请使用者自行确认。 v0.3.0 发布日志django-echarts v0.3.0 正式发布。该版本将 仅支持 Python3.5+ 以及 Django2.0+ 的环境，同时该增加了若干个功能特性： 移除对 Python2 的支持 新增计数模块 datasets.section_counter 部分函数增加 Key-Only Arguments ( PEP 3102 ) 限定 下载命令增加 --fake 选项，支持预览调试 整合单元测试 发布数据构建文档 1 Python3迁移django-echarts 使用了更为激进的迁移策略，v0.3之后将仅支持 Python3.5+ 以及 Django2.0+ 的运行环境，不再支持 Python2 ，django-echarts v0.3 将在 Python2 环境中出现语法层面的错误。 具体来说就是 PEP 3102 的应用，在3.X中新增了强制关键字参数传递（Keyword-Only Arguments）中，定义的形式为使用 * 单独占用一个参数，表示之后的参数必须以关键字方式传入参数，否则将引发TypeError异常。 例子： django_echarts.plugins.host.HostStore 12345class HostStore(object): HOST_DICT = &#123;&#125; def __init__(self, *, context=None, default_host=None): pass django_echarts.plugins.store.SettingsStore 123class SettingsStore(object): def __init__(self, *, echarts_settings=None, extra_settings=None, **kwargs): pass 是否使用 Keyword-Only Arguments ，自己根据实际情况总结了一些应用场景。 函数有两个以上的可选参数（提供了默认参数） 这些参数的功能意义是平等的，通常可任意调换位置 比如 django_echarts.datasets.section_counter.BSectionIndex 类的 __init__ 就没有使用这个特性，因为 [lower, upper] 更符合实际表达形式。 123class BSectionIndex(BIndex): def __init__(self, lower=None, upper=None): pass 2 计数模块 section_counter该模块针对常见的数据计数业务场景进行的封装，该模块基于内置 collections.Counter 模块，并基于此进行了一些扩展。 BSectionCounter 库用于计算符合一系列条件的数目计数类。 先看一个例子 123456789101112data_list = list(df['stars'])labels = ['00~00', '01~10', '11~50', '51~100', '101~500', '501~1000', '&gt;1000']sizes = []sizes.append(len([pp for pp in data_list if pp == 0]))sizes.append(len([pp for pp in data_list if pp &gt;= 1 and pp &lt;= 10]))sizes.append(len([pp for pp in data_list if pp &gt;= 11 and pp &lt;= 50]))sizes.append(len([pp for pp in data_list if pp &gt;= 51 and pp &lt;= 100]))sizes.append(len([pp for pp in data_list if pp &gt;= 101 and pp &lt;= 500]))sizes.append(len([pp for pp in data_list if pp &gt;= 501 and pp &lt;= 1000]))sizes.append(len([pp for pp in data_list if pp &gt;= 1001]))stargazer_bar = Bar("stars", "stars hist graph of users", width=CHART_WIDTH)stargazer_bar.add("", labels, sizes, is_label_show=True, mark_line=["average"]) 使用 BSelectionCounter 后，简化为 12345678910111213data_list = list(df['stars'])rc1 = BSectionCounter( BValueIndex(0), BSectionIndex(1, 10), BSectionIndex(11, 50), BSectionIndex(51, 100), BSectionIndex(101, 500), BSectionIndex(501, 1000), BSectionIndex(1001))labels, sizes = rc1.feed_as_axises(data_list)stargazer_bar = Bar("stars", "stars hist graph of users", width=CHART_WIDTH)stargazer_bar.add("", labels, sizes, is_label_show=True, mark_line=["average"]) 3 下载命令支持预览调试增加 --fake 后，命令将仅打印出对应文件的下载路径、引用路径、存储位置，而 不会进行任何实际的下载操作 ，可用于预览调试。 例子： 123456789&gt;&gt;&gt;python manage.py download_echarts_js echarts.min china --fake[Info] Download Meta for [echarts.min] Remote Url: https://cdn.bootcss.com/echarts/3.7.0/echarts.min.js Local Url: /static/echarts/echarts.min.js Local Path: E:\projects\django-echarts\example\static\echarts\echarts.min.js[Info] Download Meta for [china] Remote Url: http://echarts.baidu.com/asset/map/js/china.js Local Url: /static/echarts/china.js Local Path: E:\projects\django-echarts\example\static\echarts\china.js fake 命名灵感来自于 migrate命令 。 4 发布数据构建文档v0.3.0 开始，有关数据构建的文档将独立出来。一方面，从功能上来说，数据构建模块仅是数据创建和渲染过程中可能使用到的工具性代码，并不是核心功能。 另一方面，由于该模块的工具特性使其具有更为一般的通用性，因此在后续开发中，有考虑将其纳入 正在编写的 “pyecharts-contrib计划’’之中。 pyecharts-contrib 计划旨在于构建通用、简单的脚手架模板，和提供解决数据可视化领域中一些常见问题的工具集合。使用者可以迅速地基于 contrib 开始新的项目。pyecharts-contrib 将追求遵循“batteries included” philosophy 。pyecharts-contrib 命名的灵感来自于 django.contrib 。 目前，该计划正在紧张有序的进行中。 5 其他功能改进其他部分功能改进。 FieldValuesQuerySet.fetch_values 类和方法重名为 AxisValuesQuerySet.as_axis_values 更加符合实际意义 整合测试样例]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，2018！]]></title>
    <url>%2F2017%2F12%2F30%2Fhappy-2018%2F</url>
    <content type="text"><![CDATA[12345 ____ ___ _ ___|___ \ / _ \ / | ( _ ) __) | | | | | | | / _ \ / __/ | |_| | | | | (_) ||_____| \___/ |_| \___/ echo “2018” | figlet 2017年技术大事记按时间先后排序 主持并完成公司 NMS v2.0 项目的重构和试运行工作 维护 HydrantDeviceSystem 项目 完成个人项目《水资源费征收工作平台》，发布v1.2.X系列版本 阅读书籍《构建之法》 加入 pyecharts开源项目团队 撰写26篇博客文章 2017年博客总结2017年一共写了 26 篇文章，是博客重建后的完整的第一年，也是写了比较多的文章，目前总计达到38篇文章。 分类 数目 占比 2017 26 68.42% 2016 9 23.69% 2015 3 7.89% 15和16年的文章只是从其他地方迁移过来的，其中有所取舍，因此数量上显得就比较少了。 按照分类统计如下表： 分类 数目 占比 编程 24 63.15% 技术研究 10 26.32% 生活 4 10.53% 使用 Echarts 渲染图表如下： 目前还是偏重于语言技术层次，系统设计和原理性的文章还是偏少。希望自己2018年在这方面需要一定的加强。 2018年期望与规划 本职工作 pyecharts项目 https://github.com/pyecharts/pyecharts django-echarts项目 https://github.com/kinegratii/django-echarts 系统架构设计师资格考试 技术书籍阅读 继续撰写博客文章 [可选]BWS v2.0 重构工作 附录系统架构设计师系统架构设计师是一个最终确认和评估系统需求，给出开发规范，搭建系统实现的核心构架，并澄清技术细节、扫清主要难点的技术人员。 系统架构设计师考试合格人员能够根据系统需求规格说明书，结合应用领域和技术发展的实际情况，考虑有关约束条件，设计正确、合理的软件架构，确保系统架构具有良好的特性；能够对项目的系统架构进行描述、分析、设计与评估；能够按照相关标准编写相应的设计文档；能够与系统分析师、项目管理师相互协作、配合工作；具有高级工程师的实际工作能力和业务水平。 考试要求 （1）掌握计算机硬软件与网络基础知识； （2）熟悉信息系统开发过程； （3）理解信息系统开发标准、常用信息技术标准； （4）熟悉主流的中间件和应用服务器平台； （5）掌握软件系统建模、系统架构设计技术； （6）熟练掌握信息安全技术、安全策略、安全管理知识； （7）了解信息化、信息技术有关法律、法规的基础知识； （8）了解用户的行业特点，并根据行业特点架构合适的系统设计； （9）掌握应用数学基础知识； （10）熟练阅读和正确理解相关领域的英文文献。 考试科目设置 （1）信息系统综合知识，考试时间为150分钟，笔试，选择题； （2）系统架构设计案例分析，考试时间为90分钟，笔试，问答题； （3）系统架构设计论文，考试时间为120分钟，笔试，论文题。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>里程碑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyecharts 开发笔记]]></title>
    <url>%2F2017%2F11%2F23%2Fpyecharts-development-note%2F</url>
    <content type="text"><![CDATA[本文已收录于 《pyecharts 开发专辑》 。 本文记录了在 pyecharts 开发过程中的一些想法思路和具体问题分析解决的方案。写作本文的目的主要有两个：一是工作总结，每完成一项工作需要静下心来总结工作得失，这就是一种进步和成长；二是技术分享，对于同一个知识和技术，每个人的理解和思考都是不同的，博客提供了一个很好的分享平台。 本文基于 PR 自定义模板 整理。 总体思想最初的想法大约七八月份的时候就尝试了写了 django-echarts 这个项目，发现一些细节性问题处理起来不太方便，更为主要的是一个整体的架构没有完整的建立起来。直到十月份的时候才腾下时间思考这个问题。 因为本人是主要从事 Django 开发的，因此代码风格和思想难免受到 Django 的影响，比如基于类的代码、Mixin模式，还有一些变量命名等等。 从 OPP 到 OOP面向过程和面向对象是两种不同的设计和编码方法。在我看来，虽然二者互有优劣，但并不是排他的。在前期开发过程中，使用面向过程的方法更有助于我们描述功能，把场景活动翻译成程序语言，因为我们自己就是一个过程性的思维，“先做什么，再做什么”。 随着开发不断推进，我们逐渐了解其内在的联系，抽象出对象、动作、接口等概念，进而能够应用继承、多态等面向对象的思想。 Python 之所以称之为万能胶水，我觉得一个原因是 Python 在面向过程和面向对象之间切换自由。描述同一语言 Python 不像 Java 那些，一上来就各种类，各种继承。 规则、公开、API这个主要是和 Python 语言特点有关，Python 是比较灵活的。比如 Python 对于属性权限限制是“约定俗称”的。下面的 js_dependencies 属性应当被看成是私有的。 123456class Chart(object): def __init__(self): self._js_dependencies = &#123;&#125; @property def js_dependencies(self): return self._js_dependencies 但是，你也可以直接使用 chart._js_dependencies 来访问，只不过： IDE 可能会发出警告（warnings） 变更无法预料，从开发者的角度，无需为此语句有效性提供任何保障 使用 @property 语法公开了该类的一个访问接口。 当然，何时公开、怎么公开又是另外一个问题了。 持续开发与废弃策略这里的持续性开发指的的公共API的稳定性，更为确切的说是废弃策略。随着项目的不断推进，新代码不断加入，旧代码不断淘汰。但由于开源项目的公开性和考虑其稳定性，无用的代码并总是立即被删除，而是经过一段时间后再删除，在这方面，个人 Django 项目做的比较好，将旧有代码按照淘汰进程分几个等级(链接) ，我自己在此基础上增加了一个等级：Not Recommend ，通常用于重大变更，涉及到核心代码 不再推荐使用(Not Recommend)：仅在更新日志和文档中表明 废弃(Deprecated)：使用 warnings 模块表明 移除(Removed)：删除相关代码 功能设计与实现html转义与Python实现转义字符串（Escape Sequence）也称字符实体(Character Entity)。在HTML中，定义转义字符串的原因有两个：第一个原因是像“&lt;”和“&gt;”这类符号已经用来表示HTML标签，因此就不能直接当作文本中的符号来使用。为了在HTML文档中使用这些符号，就需要定义它的转义字符串。当解释程序遇到这类字符串时就把它解释为真实的字符。在输入转义字符串时，要严格遵守字母大小写的规则。第二个原因是，有些字符在ASCII字符集中没有定义，因此需要使用转义字符串来表示。 字符串安全 如果启用了手动转义，按需转义变量就是 你的 责任。要转义什么？如果你有 一个 可能 包含 &gt; 、 &lt; 、 &amp; 或 &quot; 字符的变量，你必须转义 它，除非变量中的 HTML 有可信的良好格式。转义通过用管道传递到过滤器 |e 来实现: 。 当启用了自动转移，默认会转移一切，除非值被显式地标记为安全的。可以在应用中 标记，也可以在模板中使用 |safe 过滤器标记。这种方法的主要问题是 Python 本 身没有被污染的值的概念，所以一个值是否安全的信息会丢失。如果这个信息丢失， 会继续转义，你最后会得到一个转义了两次的内容。 显示地标记值安全的有两种方式： 在模板中使用 safe 过滤器 传递给模板的值用 Markup 类包裹下 根据 官方文档 ，Markup 可以无需转义即可标记一个字符串为安全的。这是通过实现 __html__ 接口来实现的。Markup 是 unicode 的直接子类，拥有其众多的方法和属性。核心代码如下： 123class Markup(text_type): def __html__(self): return self 其使用方式如下： 12345678&gt;&gt;&gt; Markup("Hello &lt;em&gt;World&lt;/em&gt;!")Markup(u'Hello &lt;em&gt;World&lt;/em&gt;!')&gt;&gt;&gt; class Foo(object):... def __html__(self):... return '&lt;a href="#"&gt;foo&lt;/a&gt;'...&gt;&gt;&gt; Markup(Foo())Markup(u'&lt;a href="#"&gt;foo&lt;/a&gt;') Jinja2 的 Markup 类至少与 Pylons 和 Genshi 兼容。预计不久更多模板 引擎和框架会采用 __html__ 的概念。 Django 目前也支持 __html__ 接口协议。其数据实体定义在 django.utils.safestring.SafeData 。源代码如下： 12345678class SafeData(object): def __html__(self): """ Returns the html representation of a string for interoperability. This allows other template engines to understand Django's SafeData. """ return self js 内嵌引入的正则替换主要指的是 pyecharts.utils.freeze_js 的原理是先渲染生成 html 文件字符串，再使用正则替换，这在之前是没有问题，引入自定义模板后，模板文件也有可能引用其他文件（如 bootstrap.min.js），这样的话，碰到该行直接出现错误。 改进的办法是在渲染的过程就根据配置决定是否替换，因此该函数也可移除。 和 Flask 整合问题 此种方式是整合过程中产生一个代码版本，后来发现会破坏 Flask 原有的功能，因此改写为下一节的代码版本。但此种整合方式也是思考的一个过程，因此没有将此删除。 这是上周末刚刚完成的内容，解决在 Flask 框架中使用模板函数的问题。主要代码摘抄如下： 12345678910111213from jinjia2 import Environment as BaseEnvironmentclass Environment(BaseEnvironment): """Works like a regular Jinja2 environment but has some additional knowledge of how Flask's blueprint works so that it can prepend the name of the blueprint to referenced templates if necessary. """ def __init__(self, app, **options): if 'loader' not in options: options['loader'] = app.create_global_jinja_loader() BaseEnvironment.__init__(self, **options) self.app = app pyecharts 模板引擎 1234567891011121314151617181920212223242526272829from jinjia2 import Environmentclass EchartsEnvironment(Environment): """Built-in jinja2 template engine for pyecharts """ def __init__(self, pyecharts_config=None, *args, **kwargs): self._pyecharts_config = pyecharts_config or PyEchartsConfig() loader = kwargs.pop('loader', None) if loader is None: loader = FileSystemLoader( self._pyecharts_config.echarts_template_dir) super(EchartsEnvironment, self).__init__( keep_trailing_newline=True, trim_blocks=True, lstrip_blocks=True, loader=loader, *args, **kwargs) # Add PyEChartsConfig self.globals.update(&#123; 'echarts_js_dependencies': echarts_js_dependencies, 'echarts_js_dependencies_embed': echarts_js_dependencies_embed, 'echarts_container': echarts_container, 'echarts_js_content': echarts_js_content, 'echarts_js_content_wrap': echarts_js_content_wrap &#125;) 代码解析要点如下： Flask.Environment 新增了两点扩展： 增加了一个必要的 app 成员变量，这是一个 Flask 实例 同时提供了默认的 loader 。 pyecharts.engine.EchartsEnvironment 也有两点扩展： 增加了一个可选 pyecharts_config 成员变量 同时提供了默认的 loader。 整合的目标是实现一个类，使得同时具有以上四个特点。 主要整合方式： 第一种：Mixin 方式。这种方式是实现最为简单，但是在此种情况下却无法使用，这是因为二者都重写了 __init__ ，都涉及到对象的创建过程，不建议使用。 第二种是代码混合方式：让一个直接继承 jinja2.Environment ，将另外一个的代码搬入。因为 Flask.Environment 的代码比较少，继承 EchartsEnvironment 是更为优化的。 下面是使用第二种方式整合的最终代码及其使用方法： 123456789101112131415161718# ----- Adapter ---------class FlaskEchartsEnvironment(EchartsEnvironment): def __init__(self, app, **kwargs): EchartsEnvironment.__init__(self, **kwargs) self.app = app# ---User Code ----class MyFlask(Flask): jinja_environment = FlaskEchartsEnvironment jinja_options = &#123;'pyecharts_config': PyEchartsConfig( jshost='https://cdn.bootcss.com/echarts/3.7.2', echarts_template_dir='templates' )&#125;app = MyFlask(__name__) 因为 EchartsEnvironment 显式传入了 loader 参数，抵消了 Environment 类 loader 的重写逻辑。 目前该代码放在 demo 内，没有整合为 pyecharts 一部分。 web框架整合优化上一节实现有个重大问题，表面上看会覆盖原有模板目录功能，导致必须现实设置 echarts_template_dir 。因此必须继承 flask.templating.Environment 以保全全部功能。 12345678910111213141516171819202122232425from __future__ import unicode_literalsimport randomimport datetimefrom flask import Flask, render_templatefrom flask.templating import Environmentfrom pyecharts import HeatMapfrom pyecharts.engine import PyEchartsConfigMixin, ECHAERTS_TEMPLATE_FUNCTIONSfrom pyecharts.conf import PyEchartsConfigclass FlaskEchartsEnvironment(Environment, PyEchartsConfigMixin): pyecharts_config = PyEchartsConfig( jshost='https://cdn.bootcss.com/echarts/3.7.2' ) def __init__(self, *args, **kwargs): super(FlaskEchartsEnvironment, self).__init__(*args, **kwargs) self.globals.update(ECHAERTS_TEMPLATE_FUNCTIONS)class MyFlask(Flask): jinja_environment = FlaskEchartsEnvironmentapp = MyFlask(__name__) 之后和标准的 Flask 项目一样使用。 命名借鉴比如 Page.from_charts 借鉴了 django.db.models.Manager.from_queryset 。又比如类 Mixin 模式变量方法的命名。 12345678clas DemoMixin(object): foo1 = None foo2 = None def get_foo1(self): return self.foo1 def get_foo2(self): return self.foo2 Python 2/3json.dumps 输出结果12345import jsonc = &#123;'date':'2017-01-01', 'a':'1'&#125;data = json.dumps(c, indent=0)print(len(data))print('*'.join(data)) 上述代码在 2 和 3 环境下运行结果是不同的，结果如下： 环境：Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] 1234534&#123;**&quot;*d*a*t*e*&quot;*:* *&quot;*2*0*1*7*-*0*1*-*0*1*&quot;*,**&quot;*a*&quot;*:* *&quot;*1*&quot;**&#125; 环境：2.7.14 (v2.7.14:84471935ed, Sep 16 2017, 20:25:58) [MSC v.1500 64 bit (AMD64)] 1234535&#123;**&quot;*d*a*t*e*&quot;*:* *&quot;*2*0*1*7*-*0*1*-*0*1*&quot;*,* **&quot;*a*&quot;*:* *&quot;*1*&quot;**&#125; 简而言之，将字典转化为json字符串时，python2 在每一对键值分割符“,”增加了一个空格 下面是测试 pyecharts.utils.json_dumps 功能的测试代码（使用 nosetests 框架）。影响到的是最后测试的时候直接使用表达式结果作为 assert 语句的第一个参数，这是一个取巧的方法，因为目前没有引入 six 等兼容库，代码需要多写。 1234567891011121314151617181920212223242526272829303132import jsonfrom datetime import date, datetimeclass UnknownTypeEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, (datetime.datetime, datetime.date)): return obj.isoformat() else: try: return obj.astype(float).tolist() except Exception: try: return obj.astype(str).tolist() except Exception: return json.JSONEncoder.default(self, obj)def json_dumps(data, indent=0): return json.dumps(data, indent=indent, cls=UnknownTypeEncoder)def test_json_encoder(): """ Test json encoder. :return: """ data = date(2017, 1, 1) eq_(json.dumps(&#123;'date': '2017-01-01', 'a': '1'&#125;, indent=0), json_dumps(&#123;'date': data, 'a': '1'&#125;)) data2 = &#123;'np_list': np.array(['a', 'b', 'c'])&#125; data2_e = &#123;'np_list': ['a', 'b', 'c']&#125; eq_(json.dumps(data2_e, indent=0), json_dumps(data2)) 上述测试代码是一个不好的实践方法，把测试目标改变了，上面测试的是 data2_e 和 data2 的 json 输出是否一致，而不是 data2 的 json 是否符合预期的 json 格式，这二者是截然不同的，显然我们要测试的是后者。 假设 json.dumps 输出不是符合标准的 json 数据，上述测试案例可以通过，但在之后的功能测试是不能通过的。 上述的测试代码已经蕴含了 json.dumps 一定能输出标准的 json 数据，这当然是。 按照测试原则，assert 语句的第一个应当是表征字面量，下面就是一个简单的对比。 123456DEFAULT_HOST = 'https://chfw.github.io/jupyter-echarts/echarts'def test_pyecharts_remote_jshost(): target_config = PyEchartsConfig(jshost=DEFAULT_HOST) eq_('https://chfw.github.io/jupyter-echarts/echarts', target_config.jshost) # 良好的实践 eq_(DEFAULT_HOST, target_config.jshost) # 糟糕的实践 函数不定参数定义与调用在 Python3 中，函数定义时允许常规变量(regular argument)出现在一个不定参数(varargs argument)之后，如下面的函数。12def sortwords(*wordlist, case_sensitive=False): ... 需要注意的是，调用的时候 case_sensitive 必须以关键字形式传入，类似 sortwords(&#39;Apple&#39;, &#39;Orange&#39;, case_sensitive=True) 。 更多的资料可以参考 PEP 3102 。 之前在考虑 page.from_charts(cls, *charts) 是否添加 jshost 相关参数的时候碰到这个问题，最后考虑不添加这个特性，主要基于下面两个原因： 1 如果添加这个参数，会再调用时引起歧义，有以下两种种定义形式： 第一种： Page.from_charts(jshost=None, *args) 这种方式有个问题，就是即使 jshost 无意设置，也需使用 None 占位。 Page.from_charts(chart1, chart2) 调用从字面上是将两个图表合并，实际上只有一个，调用时会把 chart1 传给 jshost 第二种：Page.from_charts(*args, jshost=None) 这个将可选的参数放置在最后，可以解决 Page.from_charts(chart1, chart2) 字面和实际效果一致，但是仅Python3.5+支持 2 从功能上来看，该方法只是 __init__ 方法的补充，不一定非要和其等价。 致谢非常感谢 @chenjiandongx 和 @chfw 两位提供问题讨论和代码复查方面的经验。]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑开发软件的5个清单]]></title>
    <url>%2F2017%2F10%2F09%2Fpc-software-checklist%2F</url>
    <content type="text"><![CDATA[长假后的第一天，把电脑换成win10 64位，也重装了一些软件。本文将记录一些其中使用的软件，包含基本软件和开发工具。 清单1：基本软件 百度输入法 好压：压缩软件 美图看看 everything：文件搜索 驱动精灵 福昕PDF阅读器 google：浏览器 adblock广告去除插件 Fences桌面整理软件 OneDrive文件存储 网易云音乐 清单2：基本开发工具 notepad++:记事本 typora:Markdown编辑器 git：代码管理库 git账号设置 SSH公钥部署到 github和码云 代码浏览器插件 清单3：社交工具 邮箱客户端 公司邮箱 个人邮箱 微信电脑版 QQ电脑版 清单4：语言及其环境 Java运行环境 JRE环境变量配置 python2.7 python3.6 Pycharm：Python开发环境 pip源设置 nodejs 6 npm源设置 hexo：博客构建 清单5：项目环境 Hexo博客 Hexo安装 依赖重新安装]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>清单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django2笔记:路由path语法]]></title>
    <url>%2F2017%2F09%2F25%2Fdjango2-url-path%2F</url>
    <content type="text"><![CDATA[9月23，Django 发布了2.0a1版本，这是一个 feature freeze 版本，如果没有什么意外的话，2.0正式版不会再增加新的功能了。按照以往的规律，预计正式版将在12月发布。 备注：Django 2.0 于12月2日已经正式发布。 （链接） 2.0无疑是一个里程碑版本，移除了对 Python2.7 的支持，最少需要 3.4 以上，建议使用3.5以上的版本。 What’s new in Django2.0 文档中一共列出了三个新的特性： 更简单的URL路由语法 (Simplified URL routing syntax) admin应用的针对移动设备的优化改进(Mobile-friendly contrib.admin) 支持SQL开窗表达式(Window expressions) 第一个特性，主要用于动态路由定义上。在Django2.0代码实现中，主要的变化是新增了 django.urls.path 函数，它允许使用一种更加简洁、可读的路由语法。比如之前的版本的代码： 1url(r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$', views.year_archive), 在新版本中也可以写为： 1path('articles/&lt;int:year&gt;/', views.year_archive), 新语法支持类型转化，在上述的例子中， year_archive 函数接收到的year参数就变成整数而不是字符串。 如果你有接触过 Flask 框架，就会发现和 Variable-Rules 的语法形式和功能都是相类似的。 一 问题引入下面是 Django1.X 的一段代码： 123456789101112131415161718192021from django.conf.urls import urldef year_archive(request, year): year = int(year) # convert str to int # Get articles from databasedef detail_view(request, article_id): passdef edit_view(request, article_id): passdef delete_view(request, article_id): passurlpatterns = [ url('articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/', year_archive), url('article/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/detail/', detail_view), url('articles/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/edit/', edit_view), url('articles/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/delete/', delete_view),] 考虑下这样的两个问题： 第一个问题，函数 year_archive 中year参数是字符串类型的，因此需要先转化为整数类型的变量值，当然 year=int(year) 不会有诸如如TypeError或者ValueError的异常。那么有没有一种方法，在url中，使得这一转化步骤可以由Django自动完成？ 第二个问题，三个路由中 article_id 在业务中表示同一个字段，使用同样的正则表达式，但是你需要写三遍，当之后 article_id 规则改变后，需要同时修改三处代码，那么有没有一种方法，只需修改一处即可？ 在 Django2.0 中，可以使用 path 解决以上的两个问题。 二 使用示例这是一个简单的例子： 12345678910from django.urls import pathfrom . import viewsurlpatterns = [ path('articles/2003/', views.special_case_2003), path('articles/&lt;int:year&gt;/', views.year_archive), path('articles/&lt;int:year&gt;/&lt;int:month&gt;/', views.month_archive), path('articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug&gt;/', views.article_detail),] 基本规则： 使用尖括号(&lt;&gt;)从url中捕获值。 捕获值中可以包含一个转化器类型（converter type），比如使用 &lt;int:name&gt; 捕获一个整数变量。若果没有转化器，将匹配任何字符串，当然也包括了 / 字符。 无需添加前导斜杠。 以下是根据 2.0官方文档 而整理的示例分析表： 请求URL 匹配项 视图函数调用形式 /articles/2005/03/ 第3个 views.month_archive(request, year=2005, month=3) /articles/2003/ 第1个 views.special_case_2003(request) /articles/2003 无 - /articles/2003/03/building-a-django-site/ 第4个 views.article_detail(request, year=2003, month=3, slug=”building-a-django-site”) 三 path转化器 文档原文是Path converters，暂且翻译为转化器。 Django默认支持以下5个转化器： str,匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式 int,匹配正整数，包含0。 slug,匹配字母、数字以及横杠、下划线组成的字符串。 uuid,匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00。 path,匹配任何非空字符串，包含了路径分隔符 四 自定义转化器4.1 定义对于一些复杂或者复用的需要，可以定义自己的转化器。转化器是一个类或接口，它的要求有三点： regex 类属性，字符串类型 to_python(self, value) 方法，value是由类属性 regex 所匹配到的字符串，返回具体的Python变量值，以供Django传递到对应的视图函数中。 to_url(self, value) 方法，和 to_python 相反，value是一个具体的Python变量值，返回其字符串，通常用于url反向引用。 先看看默认的 IntConverter 和 StringConverter 是怎么实现的： 123456789101112131415161718class IntConverter: regex = '[0-9]+' def to_python(self, value): return int(value) def to_url(self, value): return str(value)class StringConverter: regex = '[^/]+' def to_python(self, value): return value def to_url(self, value): return value 第二个例子，是自己实现的4位年份的转化器。 12345678class FourDigitYearConverter: regex = '[0-9]&#123;4&#125;' def to_python(self, value): return int(value) def to_url(self, value): return '%04d' % value 4.2 注册使用register_converter 将其注册到URL配置中： 1234567891011from django.urls import register_converter, pathfrom . import converters, viewsregister_converter(converters.FourDigitYearConverter, 'yyyy')urlpatterns = [ path('articles/2003/', views.special_case_2003), path('articles/&lt;yyyy:year&gt;/', views.year_archive), ...] 五 使用正则表达式如果上述的paths和converters还是无法满足需求，也可以使用正则表达式，这时应当使用 django.urls.re_path 函数。 在Python正则表达式中，命名式分组语法为 (?P&lt;name&gt;pattern) ，其中name为名称， pattern为待匹配的模式。 之前的示例代码也可以写为： 12345678910from django.urls import path, re_pathfrom . import viewsurlpatterns = [ path('articles/2003/', views.special_case_2003), re_path('articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/', views.year_archive), re_path('articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/', views.month_archive), re_path('articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/(?P&lt;slug&gt;[^/]+)/', views.article_detail),] 这段代码和之前的代码实现了基本的功能，但是还是有一些区别： 这里的代码匹配更加严格，比如year=10000在这里就无法匹配。 传递给视图函数的变量都是字符串类型，这点和 url 是一致的。 无命名分组 一般来说，不建议使用这种方式，因为有可能引入歧义，甚至错误。 六 Import变动django.urls.path 可以看成是 django.conf.urls.url 的增强形式。 为了方便，其引用路径也有所变化，请注意下 urls 包路径的变更，不再是 conf 的子包了，目前和 views 、conf 一样，被认为是 Django 的核心组件。 1.X 2.0 备注 - django.urls.path 新增，url的增强版 django.conf.urls.include django.urls.include 路径变更 django.conf.urls.url django.urls.re_path 异名同功能，url不会立即废弃 七 代码改写将“问题引入”一节的代码使用新的path函数可以改写如下： 12345678910111213141516171819202122232425262728293031323334from django.urls import path, register_converterfrom django.urls.converters import SlugConverterclass FourDigitYearConverter: regex = '[0-9]&#123;4&#125;' def to_python(self, value): return int(value) def to_url(self, value): return '%04d' % valueregister_converter(SlugConverter, 'article_id')register_converter(FourDigitYearConverter, 'year')def year_archive(request, year): print(type(year)) # &lt;class 'int'&gt; # Get articles from databasedef detail_view(request, article_id): passdef edit_view(request, article_id): passdef delete_view(request, article_id): passurlpatterns = [ path('articles/&lt;year:year&gt;/', year_archive), path('article/&lt;article_id:article_id&gt;/detail/', detail_view), path('articles/&lt;article_id:article_id&gt;/edit/', edit_view), path('articles/&lt;article_id:article_id&gt;/delete/', delete_view),] 八 总结第一，目前 路由（url）到视图（View）的流程可以概括为四个步骤： url匹配 正则捕获 变量类型转化 视图调用 Django2.0 和之前相比多了 变量类型转化 这一步骤。 第二，新的path语法可以解决一下以下几个场景： 类型自动转化 公用正则表达式 问题描述可参考 “问题引入” 一节。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-Echarts系列：js依赖文件管理]]></title>
    <url>%2F2017%2F09%2F06%2Fdjango-echarts-js-manage%2F</url>
    <content type="text"><![CDATA[本文已收录于 《pyecharts 开发专辑》 。 django-echarts 是本人正在开发的一个开源项目，该项目旨在将 pyecharts 库整合到Django web框架中，从而形成echarts-python-django 大整合的项目。 继之前简单的一个使用示例之后，最近花了几天完成了一种的一个功能插件：js依赖文件管理。 1 Django-Echarts概述django-echarts这个项目的目标和pyecharts是一致的，即在目标html页面上渲染图表。要完成一个Echarts图表，从最后渲染完成的HTML结构来看，至少应当包含以下三个部分： 图表容器控件，比如&lt;div id=&quot;id_mycharts&quot;&gt;&lt;/div&gt; js依赖文件，比如 &lt;script src=&#39;/static/echarts/echarts.min.js&#39;&gt;&lt;/script&gt; 图表初始化代码,代码中 myCharts.setOptions(Foo) 所在的script标签。 这个排序按照一般出现的顺序，将所有 script 标签放置在body标签的最后，有利于页面的加载。 在这一过程中，pyecharts 项目为此做了大量的工作，使得我们能够快速地依据功能要求构建出模板渲染所需的数据，这些数据在Django模板系统中称之为 Context。 在实际应用过程中，每个页面的结构都是各式各样的，不能一概而论，因此django-echarts的主要职责： 如何创建上述三个标签（代码片段）。 上述标签在目标html的位置和结构由用户选择。 对于一些简单的页面，可以提供一些shortcut工具。 2 设计思路2.1 目标三者之前没有太大的关联性，是可以单独拿出来讨论其设计思想和实现方式的。js 依赖文件管理最终的目标是构建js文件路径字符串。 12&lt;script src='/static/echarts/echarts.min.js'&gt;&lt;/script&gt;&lt;script src='/static/echarts/map/china.js'&gt;&lt;/script&gt; 虽然最后生成的是一个或多个script标签，但依据 Django MTV 原则，标签的构建应当由模板系统负责。 核心的src属性由路径和js文件名两部分组成。路径的意义在于，对于同一个 echarts.min.js 可以由不同的地方提供，这称之为repository。而文件名是由用户输入提供的。使用代码表示如下： 123def generte_js_link(js_name): host = '' # TODO Where to pick a host according the settings return '&#123;host&#125;/&#123;js_name&#125;.js'.format(host=host, js_name=js_name) 2.2 问题综上所述，js 依赖文件管理解决的问题： 需要管理哪些依赖文件 哪些repository可以提供js文件，其中哪些可以实现对其的支持。 如何在不同repository之间尽可能平稳的切换，即它们之间必须提供统一的API 需要对外提供哪些API，即在哪些情况下可能使用到这个功能 3 仓库(repository)与文件按照正常逻辑，文件名由用户根据实际功能需求指定，其有效性应当交由用户确保。在实际过程不同repository可提供的文件是不一样。js文件分为核心库文件和地图数据文件两种。pyecharts能够提供本地和远程两种类型的repository，加上Django整合时，项目静态文件也可以作为一种repository存在，因此共有三种。 将repository和文件类型进行交叉分析，可整理出以下的一张表格： 仓库 核心库文件 地图数据文件 核心库版本支持 远程/ 本地 pyecharts本地 可提供 可提供 无，不可控 本地 pyecharts远程 可提供 可提供 无，不可控 远程 官方CDN 不提供 提供 - 远程 公共CDN 可提供 不提供 支持 远程 项目静态目录 可自定义 可自定义 可自定义 本地 分析如下： 首先的是pyecharts本地作为存储仓库是不太合适，同为本地文件存储，Django项目静态库显然是一个更为合适的选择。 pyecharts远程库，路径为 https://chfw.github.io/jupyter-echarts/echarts， 该库的优势在于提供了一些列的自定义地图，但弱势是核心库文件没有版本管理，而且 github 仓库不建议作为静态文件托管服务。 官方CDN：其实指的是地图文件数据下载的源地址。 公共CDN：优势在于支持版本管理，缺点是不提供地图数据文件。公共CDN仅选择Echarts官方教程提及的三个CDN，其余的已经很久没有更新了。 项目静态目录：通常由 setttings.STATIC_URL指定。 这是开发者自己从零开始构建的，因此自由度最大。为了方便，可开发从其他远程仓库下载文件的功能。 一个通常的使用场景如下： 试验django-echarts，仅使用远程仓库，这样不必配置静态文件设置等。 如果可用，通过下载工具下载到本地，并进行一系列开发。 部署上线时，根据需要切换到CDN。 4 配置4.1 基本配置配置是项目初始化需要使用的。默认的配置如下： 123456DEFAULT_SETTINGS = &#123; 'echarts_version': '3.7.0', 'lib_js_host': 'bootcdn', 'map_js_host': 'echarts', 'local_host': None&#125; 在实际运行之前，会将用户自定义配置和默认配置进行合并，并向外提供统一的模块变量用于访问。 关于这一部分可以期待之后的《django-echarts系列：配置模块》一文。 由于核心库文件和地图数据文件需要分开托管，因此需要使用两个变量分别指定和设置。二者都有自己有效的可选值。 4.2 远程/本地切换 local_host的作用有两点： 提供公用变量，当 lib_js_host 和 map_js_host 同时指定本地仓库时，可以借助该变量 下载工具的目标目录。 5 运行分析5.1 分开托管和文件识别由于不同仓库提供的文件不同，通常分为可提供核心库文件和地图数据文件，因此需要分别两个查询表（在Python使用一个dict表示即可）。 这就带来了一个问题：用户输入的是 js_name，只有这个参数，而且由于自定义地图文件，理论上可以是任何一个有效的文件名字符串，如何识别为核心库文件还是地图数据文件，即从哪个字典查询，成了一个待解决的问题。 这个没有一个百分百正确的答案。目前采用一个简单办法：由于公共CDN提供的核心库文件是一定的，可提供一个核心库文件列表，判断js_name是否在其中即可。 5.2 输出URL当确定完某一个仓库后，之后的url构建就比较简单了，本质上来说是python string format的一些封装。仓库路径具体和一些因素有关，这些因素都需要在项目初始化就已经确定了，放在 settings 模块是最为合适了。目前支持以下字段： echarts_version：版本字符串，一些公共CDN需要指定版本号。 STATIC_URL：静态文件目录，通常用于项目本地仓库，该值等于settings.STATIC_URL. 在实现过程中，也有两点问题需要注意： 字段的大小写问题，为了和settings.STATIC_URL一致，也采用了大写变量 目录后缀/ ,依据Django规范 STATIC_URL是带有/的，而pyecharts的远程路径没有带有/，以及自己设置的第三方CDN中，这个问题需要作统一处理。目前是按照pyecharts没有带有/，不排除之后会依照Django规范，但是对外部使用是没有任何影响的。 基本代码 1234567891011121314151617181920class Host(object): HOST_LOOKUP = &#123;&#125; def __init__(self, name_or_host, context=None, host_lookup=None, **kwargs): context = context or &#123;&#125; host_lookup = host_lookup or self.HOST_LOOKUP host = host_lookup.get(name_or_host, name_or_host) try: self._host = host.format(**context).rstrip('/') except KeyError as e: self._host = None raise KeyError('The "&#123;0&#125;" value is not applied for the host.'.format(*e.args)) @property def host_url(self): return self._host def generate_js_link(self, js_name): return '&#123;0&#125;/&#123;1&#125;.js'.format(self._host, js_name) 5.3 渲染html这一过程是Django模板系统负责的，为了方面可以自定义一个模板标签echarts_js_dependencies解决这个问题。 以下是基本代码 123456789101112131415@register.simple_tag(takes_context=True)def echarts_js_dependencies(context, *args): links = [] for option_or_name in args: if isinstance(option_or_name, Base): for js_name in option_or_name.get_js_dependencies(): if js_name not in links: links.append(js_name) elif isinstance(option_or_name, six.text_type): if option_or_name not in links: links.append(option_or_name) links = map(DJANGO_ECHARTS_SETTING.host_store.generate_js_link, links) return template.Template('&lt;br/&gt;'.join(['&lt;script src="&#123;link&#125;"&gt;&lt;/script&gt;'.format(link=l) for l in links])).render( context) 有几个注意点： 标签是支持多个script渲染的。 为了方便，列表的每一项支持 文件名或者 pyecharts.base.Base对象。 在多个标签输出时，需要去掉那些重复的文件。 因为html结构简单，所以使用register.simple_tag 就可以了。 6 CLI与Django命令基于 django manage command 实现一个简单的 CLI，其核心功能是js文件下载。 下载工具提供将远程的js文件同步到本地静态文件目录中。该功能为manage命令，需符合其的一些用法规范。 12345usage: manage.py download_echarts_js [-h] [--version] [-v &#123;0,1,2,3&#125;] [--settings SETTINGS] [--pythonpath PYTHONPATH] [--traceback] [--no-color] [--js_host JS_HOST] js_name [js_name ...] 远程仓库的选择和限制条件可以使用伪代码表示如下： 12345678910111213host = &apos;&apos;if(命令提供了--js_host参数)&#123; host = js_host参数值&#125;else&#123; if(js_name是否和核心库文件)&#123; host = settings.DJANGO_ECHARTS[&apos;lib_js_host&apos;] &#125;else&#123; host = settings.DJANGO_ECHARTS[&apos;map_js_host&apos;] &#125;&#125;if(host不是本地仓库)&#123; 执行后续操作&#125; 本地仓库的选择：只有一个限制条件就是符合本地仓库的要求，即必须以 settings.STATIC_URL 开头。 在配置方面（源目录、目标目录）仅支持 DJANGO_ECHARTS ，暂时还不支持命令行参数传入。这是下一阶段的重点内容。 7 和pyecharts的异同7.1 扩展和取舍Django-Echarts是pyecharts在Django环境的适配，在此过程中难免有所扩展和舍弃。 在本地存储（离线模式）中，使用Django项目静态目录取代pyecharts本地js存储，并提供一个下载工具将远程js文件下载到Django静态目录，以便平稳过渡。 提供一些常用CDN。 分析ECharts组成，提供一些模板标签渲染Echarts的每个部件。 由于 pyecharts 尚未实现本地 js 库的完全独立，django_echarts 只是从形式上实现独立，在实际运行过程中还会引用js相关内容，期待pyecharts在这方面有所发展。 7.2 展望 本项目是基于 pyecharts 而发展的。pyecharts是一个非常棒的项目，解决在Python中使用echarts的问题，加强了Python在数据可视化方面的应用。 另一方面pyecharts刚刚面世两三个，目前着重于Echarts实例创建这一问题上，对于外围环境的问题涉及有所不足。]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript声明文件]]></title>
    <url>%2F2017%2F08%2F27%2Ftypescript-declaration-file%2F</url>
    <content type="text"><![CDATA[TypeScript声明文件。 if you want to use relative path in the import, you will need: put the add.d.ts next to add.js define the file as an external module: 123// add.d.tsdeclare function add(n1: number, n2: number): number;export = add; i.e. loose the “declare module “add”” part. There are two ways to define declarations for a .js module: 1 using declare module &quot;foo&quot; and then you can have multiple module definitions in the same file: 123456789101112// mydefinitions.d.tsdeclare module &quot;mod1&quot; &#123; export var x = 0;&#125;declare module &quot;mod2&quot; &#123; export var y = 0;&#125;declare module &quot;mod3&quot; &#123; export var z = 0;&#125; and consuming them would have to be using absolute names: 123456// main.ts/// &lt;reference path=&quot;myDefintions.d.ts&quot; /&gt;import * as mod1 from &quot;mod1&quot;;import mod2 = require(&quot;mod2&quot;);import &#123;z&#125; from &quot;mod3&quot;; 2 alternatively you can define as a file, where the name of the file is the name of the module 1234// myModule.d.tsdeclare var m = 0;export = m; and consume it as a normal .ts module: 12import m = require(&quot;./myModule&quot;);m.toString();]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【项目】高德地图位置选择器]]></title>
    <url>%2F2017%2F08%2F09%2Famap-position-picker%2F</url>
    <content type="text"><![CDATA[基于高德地图的位置选择jQuery插件。该项目结合了个人相关开发经验，分离功能独立的构件，严格遵守javascript开发规范。现已收录于开源中国中，主页为 https://www.oschina.net/p/amappositionpicker 。 从v0.9.0起，项目名称由 bootstrap.AMapPositionPicker 更改为 AMapPositionPicker。 主要特性有： AMD &amp; CMD 引入 data-* 属性配置 初始位置数据 浏览器定位 字段显示格式、验证 数据控件绑定 支持地理逆编码 POI搜索 工具：显示点标记 基本使用1 依次引入高德地图JS、jQuery、Bootstrap和bootstrap.AMapPositionPicker.min.js文件。 1234&lt;script type="text/javascript" src="http://webapi.amap.com/maps?v=1.3&amp;key=您申请的key值"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="./dist/bootstrap.AMapPositionPicker.min.js"&gt;&lt;/script&gt; 2 在目标输入框初始化选项。 html代码 1&lt;input type="text" id="id_address_input" name="address"/&gt; JS代码 1$("#id_address_input").AMapPositionPicker(); 更多示例可查看 文档&amp;示例。 项目开发在开发过程中，参考了Eonasdan / bootstrap-datetimepicker等项目的模块结构。遵循标准通用的代码结构，以适应于多种环境。 构建项目使用gulp工具构建。 生成 release 文件 1gulp release]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>高德地图</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyecharts使用示例]]></title>
    <url>%2F2017%2F08%2F02%2Fpyecharts-example%2F</url>
    <content type="text"><![CDATA[本文已收录于 《pyecharts 开发专辑》 。 pyechart 是一个用于生成 Echarts 图表的类库。实际上就是 Echarts 与 Python 的对接。 Echarts 是百度开源的一个数据可视化 JS 库。看了官方的介绍文档，觉得很不错，就想看看有没有人实现了 Python 库可以直接调用的。Github 上找到了一个 echarts-python 不过这个项目已经很久没更新且也没什么介绍文档。借鉴了该项目，就自己动手实现一个，于是就有了 pyecharts。API 接口是从另外一个图表库 pygal 中模仿的。 目前项目还处于快速开发阶段，一些API还没有完全稳定下来。先迫不及待写了几个简单的例子。 与 tablib整合1234567891011121314import tablibfrom pyecharts import Bards = tablib.Dataset()ds.headers = ['Name', 'height']ds.append(['Tim', 167])ds.append(['John', 170])ds.append(['Tus', 159])ds.append(['Bob', 159])bar = Bar('The height')bar.add('Height', ds.get_col(0), ds.get_col(1))bar.render('height_bar.html') 显示示例 与networkx整合123456789101112131415161718192021import networkx as nxfrom networkx.readwrite import json_graphfrom pyecharts import Graphg = nx.Graph()g.add_node('N1', name='Node 1')g.add_node('N2', name='Node 2')g.add_node('N3', name='Node 3')g.add_edge('N1', 'N2')g.add_edge('N1', 'N3')g_data = json_graph.node_link_data(g)print(g_data)eg = Graph('设备最新拓扑图')eg.add('Devices', nodes=g_data['nodes'], links=g_data['links'])# eg.show_config()eg.render() 显示示例 在Django中使用自己简单的实现一个在Django中使用Echarts的例子。 12345678910111213141516from django.http import JsonResponsefrom django.views.generic.base import Viewclass EchartsBaseMixin(object): option = &#123;&#125; def get_echarts_option(self, **kwargs): return self.optionclass EchartsView(EchartsBaseMixin, View): def get(self, request, **kwargs): echarts_option = self.get_echarts_option(**kwargs) return JsonResponse(data=echarts_option, safe=False)]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django项目全栈笔记]]></title>
    <url>%2F2017%2F07%2F31%2Fdjango-full-stack-note%2F</url>
    <content type="text"><![CDATA[概述BWS项目是自己一年来在开发的项目。本文就项目中一些技术选型、功能实现、项目流程做一些简单的总结。 python3虽然Python3发布已经10年之久，但是2和3之争直到今天依旧存在，对于如何学习，每个人都有自己的理解和学习策略。我个人看法： 果断学习面向未来的3； 3和2的差别对于学习过程没有太多的影响，学好了3自然也能够很快上手2了； 常见的第三方库大多数（80%以上）是支持Python3的； 不过在系统安装的时候总是23共存的，可以自由切换； 今年4月份重新开发的时候做了一个比较激进的做法：完全抛弃对Python2的支持。当时的考量，把这个项目作为Django持续学习的一个示范项目，毕竟 Django的下一个大版本2.0（预计2017年12月发布），也已经要求最低版本为3.5了。 其实在项目中使用几个Python2不支持的语法和没有的标准库，就可以达到以上目的，具体来说，在代码中使用了以下几个语法： 字典合并创建语法（PEP448） 强制关键字传参（PEP3102） 根据 PEP448，在Python3.5中可以使用更加简洁明了的代码实现合并多个字典。 123456# 3.5+combination = &#123;**first_dictionary, "x": 1, "y": 2&#125;# 3.5以下combination = first_dictionary.copy()combination.update(&#123;"x": 1, "y": 2&#125;) 另外Python3在文本和二进制方面作了比较大的改变，这对文件导入导出功能开发提供了便利，不用再纠结2的编码问题，可以集中解决业务层面的问题。 Django我也算是Django的忠实用户了，从1.4到1.11都有用到，不断看到Django的成长和壮大。1.4/1.8/1.11是LTS版本，项目使用的是1.10。这些年来Django比较大的变更有： 自定义用户类型：这个是1.5就有的功能了，之前只能使用内置的用户类，连使用邮箱作为用户名也不能直接支持； 数据库迁移：1.7借鉴 South 实现的，这个是开发的利器，修改用户模型时候可以使用命令一键将修改同步到数据库，而忽略具体的数据库类型； 自定义过滤查询：1.7，这个主要用于封装一些业务数据库查询。 多模板支持：1.8引入的，Django自己的模板引擎效率历来为人们所诟病，现在可以在Django中使用Jinja2这样的模板了。 表单控件支持模板渲染：Django表单其实是着重于后端验证，前端相对薄弱，导致定制起来没有那么顺手。最新的1.11引入的可以通过模板文件定制控件样式等等。 CBV强烈建议使用 Class-Based-View 组织视图处理函数。 Class-Based-View 是相对于Function-Based-View而言，主要支持封装，减少重复的代码编写工作，逻辑流程清晰，经过测试过的。在具体编写代码还是一定要查看源代码，才能理解其中的功能实现。 CBV的核心是Mixin模式。 Mixin是一种将多个类中的功能单元的进行组合的利用的方式，这听起来就像是有类的继承机制就可以实现，然而这与传统的类继承有所不同。通常mixin并不作为任何类的基类，也不关心与什么类一起使用，而是在运行时动态的同其他零散的类一起组合使用。 使用mixin机制有如下好处：可以在不修改任何源代码的情况下，对已有类进行扩展；可以保证组件的划分；可以根据需要，使用已有的功能进行组合，来实现“新”类；很好的避免了类继承的局限性，因为新的业务需要可能就需要创建新的子类。 现在也基本上不写视图函数了，项目上能见到的也就是 django.contrib.auth.login 等几个函数了，不过现在也要改成视图类形式了。 是否启用admin虽然admin是Django的主要优势所在，但是它的使用场景有限，主要由于整合许多功能，比如分页、过滤、搜索、增删改查和批量操作等等，相互之间具有非常高的耦合度。在没有提供公开的API下去实现一些定制往往是“牵一发而动全身”，最后基本上也改的是不成样子。 由于项目中没有使用内置的admin组件，增删改查的页面就需要多花一点时间自己去适配。 日志模型也要自己去设计，项目中我自己添加了ip这个字段，这个是原来所没有的。 后端数据API - DRF后端数据采用的是 Django Rest Framework 这个框架，覆盖了大多数需求，包括： 搜索/分页 访问权限 请求限制（频率、IP） 表单验证 前端 Amaze UI前端UI用的是 Amaze UI这个框架。不过从后来的发展形势来看，这是最为错误的决定了，主要原因在于无法和后端比较平稳地整合。 Django表单中有一个比较大的问题，如何需要定制控件样式，需要在Python代码中修改，而且需要应用的每一处都需要更改，灵活度不够。目前主要有两种解决方式： 使用Django1.11版本的模板功能，这个功能刚刚推出，文档也只有一页的内容，不太建议使用。 使用 django-crispy-forms 第三方库，这个库的思路也是使用模板html文件渲染控件，已经有一定的使用规模，但是支持 Bootstrap这样常见的UI框架，不支持 Amaze UI。 导入导出实现导入导出功能主要使用的是 tablib 和 django-import-export 这两个库，其中后者依赖前者。 导出编写 Resource， 几点值得注意的地方： 需要设置表头，不仅需要指定字段Meta.fields，同时也要显示指定 Meta.export_order 的值，通常和 Meta.fields一样即可。 Meta.fields 里的元素必须是模型的数据库字段，不能是自定义的 property，这一点和 ModelAdmin.list_display 不一样。 可以使用 dehydrate_FOO 函数重写导出内容 1234567891011class BillResource(resources.ModelResource): def get_export_headers(self): return ['流水号','月份', '类型','单价','用量', '金额'] def dehydrate_price(self, obj): return obj.get_price_display class Meta: model = models.Bill fields = ('id', 'month', 'resource_type','price', 'amout', 'total') export_order = fields 导入django-import-export也提供了几个Mixin，但问题这些和admin组件耦合很高，不利于一些自定义操作，所以直接使用tablib库比较好。根据官方文档，可以使用以下代码实现文件导入 1imported_data = Dataset().load(open('data.csv').read()) 但其实load还有几个比较重要的参数： format：文件格式，如果不写，使用自动识别，但有出错的机率，之前试验过一个xlsx文件在不同环境下识别为json文件的，因此建议这个参数也留给用户输入 headers：表示第一行是否是表头，这个参数在文档中没有表明，需要自行查看源代码获取相关信息。 所以最后就写成下面这个样子12345678class BillUploadForm(form.Form): import_file = forms.FileField() format = forms.ChoiceField(choices=(('xlsx', 'xlsx'), ('xls', 'xls')))# 导入tablib.Dataset().load(form.cleaned_data['import_file'].read(), format=form.cleaned_data['format'], headers=False) 数据库查询优化select_related函数select_related是 django.db.models.QuerySet 类的一个方法，它解决了 ORM中常见的N+1查询效率问题，关于这一部分可以参考我之前写过的一篇文章《select_related函数性能基本测试》。 更新记录在更新记录时可以使用 update_fields 参数指定只需更新的字段列表。这个参数在只更新一两个字段的时候特别有用。 12product.name = 'Name changed again'product.save(update_fields=['name']) 如果不指定参数的值，将更新所有字段。 测试和部署分离配置文件Django使用 settings 模块配置相关参数，这使得其很好的区分开发/测试/生产。 1234567- BillWorkingSystem - BillWorkingSystem - __init__.py - settings.py - test_settings.py - urls.py - wsgi.py 一个简单的test_settings.py如下，可以配置一些仅用于测试的项目，如数据目录 FIXTURE_DIRS 。 12345678910111213141516from BillWorkingSystem.settings import *class DisableMigrations(object): def __contains__(self, item): return True def __getitem__(self, item): return "notmigrations"MIGRATION_MODULES = DisableMigrations()FIXTURE_DIRS = ( os.path.join(BASE_DIR, 'fixtures').replace('\\', '/'),)UPLOAD_TEST_DATA_DIR = os.path.join(BASE_DIR, 'fixtures', 'test_data').replace('\\', '/') MIGRATION_MODULES 设置表示是否运行数据迁移脚本。上述例子设置为空，表示测试无需运行这些迁移脚本。 单元测试单元测试主要测试那些返回为实际数据（如json/yaml）的视图。 测试采用标准的 django.test.TestCase，按照文档所描述的步骤，一步一步的编写。 1234567891011121314151617181920class BillCreateTestCase(TestCaseBase): url = '/api/bill/create/' def test_success(self): data = &#123; 'enterprise': 1, 'year': 2017, 'month': 1, 'amount': 4000, 'create_name': 'Test' &#125; rsp = self.client.post(self.url, data) self.assertEqual(201, rsp.status_code) # 其他assert语句 def test_with_error_enterprise(self): data = &#123; &#125; # 参数 rsp = self.client.post(self.url, data) self.assertEqual(400, rsp.status_code) # 其他assert语句 一个基本模式， 一个TestCase表示一个主要功能，如一个POST请求 每个 test_FOO 函数表示一种情况，包括正确和无效参数 依次对响应对象的状态码和内容、数据变更进行断言(Assert)测试 docker部署之前采用的是daocloud这个平台的工具。具体可参考《使用DaoCloud部署Django项目》这篇文章。由于对docker这方面没有一个完整的学习，加上daocloud.io更新到3版本，作了一些比较大的改变，后来就决定搬迁到阿里云服务器上，这样相对比较容易把握。 后记轮子什么是轮子 wheel，写多了代码就会发现一些代码具有共同之处，将其抽象并提取，慢慢地就形成了一个库，可以和别人分享。本质上来说，Django也是一个轮子。 持续开发由于是个人项目，因此一些版本升级方面就比较随意，基本上新版本出来就完全废弃旧有版本。 第三方库稳定才是真，不要为追求标新立异而盲目升级。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[驾考点滴]]></title>
    <url>%2F2017%2F07%2F28%2Fdriver-exam%2F</url>
    <content type="text"><![CDATA[驾考记录 今天考完了科目四，一切变得那么轻松了，坐等驾照快递上门。 （2017年8月17日） 科二今天（28号），一起考四个全满贯。 四个只有我是补考的，总结一下 “技术(30%) + 心态(60%) + 运气(10%)”。 运气 今天是1道1号，路线相对比较简单，道上的车比较少。在考试的时候异常地顺利，项目之间没有作什么停顿，(一个项目完成后可以停车空档，等前面的人做完或者自己休息思考一下)。 技术 的确经过依次挂科的经历，技术上有所提升，掌握的就比较平稳了。 上车准备 调整坐姿和后视镜。考场的车真是不能比，调了很久才稍微完成； 离合器下面榻了一块，需要用泡沫垫子垫一下； 还有要说的是，轮到号的时候车可能还没回到起点（报告合格的地方离起点还有一段距离），所以在上车之前可以大概问下前一个人这车性能如何，自己心里有个底。 坡道停车和起步 停车时右前轮距边缘线30厘米以上，扣10分; 学车的时候教练说不要管右侧边线，一步留神，有可能是不合格，就不是扣10分这么简单了； 考场的车动力比较差，教练嘱咐可以加点油门，后来想想还是不加，让车乌龟慢慢爬上坡去。 直角转弯 在练习的一直掌握的比较好，主要是右侧对边线，上次考试前一天被拉了去练习十几分钟的对边线。 其次是打死方向盘的时机。 侧方停车 这个相对比较简单，进入的时候也是要对边线的，道理同直角转弯。 要注意的是车库由坡度和方向盘打死时会速度停顿下，所以要掌握离合器以便控制好车速。 曲线行驶 其实头是可以伸出窗外看看轮胎调整的，第一次考试的时候由于注意力不集中，忘了这一点，考试前几天，交管所通知说头不能伸出窗外； 基本上按照教练的，左侧铆钉和右侧喷水点沿着边线就可以了。 倒车入库 入库的时候，回正不够导致左侧空间比较大，后来还是有惊无险的完成入库了。 考试的标准通常是可以在一个范围，而教练要求是准确的一个点，按照教练的标准肯定又要训斥一顿了。] 返回起点 这时候就比较轻松了，稳稳当当开回起点就可以了。 小插曲1：经过公共车道的时候，发现前面的车在等最后的倒车入库，其中这时候靠左一点可以过去的，但为了保险起见就没有直接过去； 小插曲2：最后完全放开离合，汽车动力好像也不是很足，加点油门就可以了。 心态 心态很重要。 要放轻松，需要有“大不了当去考场走一遭”，其实驾校的场地和练习一般都会比考试的时候更加难一点。 考试的时候注意力要集中，一共就那么十几分钟。上次考试（6月20日）第一把坡道起步熄火了，可以认为是技术不熟练；第二次在曲线行驶的时候，旁边另一道的人前几秒曲线行驶挂掉了，注意力不集中，过不了几秒自己也中枪了，压到右侧黄线了。哎，可惜已经没有机会了。 练车是一个很苦逼的过程，特别是考试前几天，基本上是天天练习，顶着三十七八度的大热天，人也超级多，一个早上下来也练不了几圈。 练车能认识各种各样的人，可以互相聊聊天，缓解练车过程的无趣。 周末台风又要来了，总算这炎热的天气会变凉快一些了。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>驾考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[select_related函数性能基本测试]]></title>
    <url>%2F2017%2F07%2F11%2Fdjango-select-related-performance%2F</url>
    <content type="text"><![CDATA[缴费项目主体功能完成的差不多了，写前端JS写的都快吐了，把所有的通用的代码封装在一个文件里差不多有1500行。接下去应该主要是Bug修正和性能优化了。性能优化方面，数据库访问效率是重要的环节，使用ORM遇到的一个很常见的是 “N+1”问题，自然Django也不例外。 N+1问题以一个简单的例子说明。假设你有一个包含若干辆汽车(Car)的集合（数据库记录），每个车辆有若干个轮胎(wheel)。也就是说，汽车和轮胎是一个一对多的关系。 如果你需要，迭代出所有的汽车信息，并且对于每辆汽车打印它的轮胎信息。则可以使用以下SQL实现： 1SELECT * FROM Car; 然后对于每辆车，使用以下的SQL语句： 1SELECT * FROM wheel WHERE CarId = ? 也就是说，在此过程中进行了N+1次数据库查询操作，其中N为汽车的数目。 但是，另一种更为效率的方式，在查出所有车辆信息后，直接查询所有的轮胎的记录，在内存中查找之间的联系。 1SELECT * FROM wheel; 该例子来自于 https://stackoverflow.com/questions/97197/what-is-n1-select-query-issue 。 在Django中可以使用 select_related和 prefetch_related 查询API解决这个问题。标准查询如下： 1234# 访问数据库e = Entry.objects.get(id=5)# 再次访问数据b = e.blog 如果使用 select_related 函数后： 12345# 访问数据e = Entry.objects.select_related('blog').get(id=5)# 下面语句不会访问数据库b = e.blog 表定义123456789101112131415161718192021222324class Organization(models.Model): name = models.CharField(max_length=100) remark = models.TextField(max_length=500, null=True, blank=True)class Enterprise(models.Model): name = models.CharField(verbose_name='名称', max_length=100) catalog = models.CharField(verbose_name='分类', max_length=10, null=True, blank=True) address = models.CharField(verbose_name='地址', max_length=100, null=True, blank=True) organization = models.ForeignKey(Organization, on_delete=models.CASCADE, verbose_name='组织', null=True, blank=True) remark = models.TextField(verbose_name='备注', max_length=500, null=True, blank=True) price = models.DecimalField(verbose_name='单价', max_digits=15, decimal_places=3, default=0) unit = models.CharField(verbose_name='单位', max_length=10, null=True, blank=True) charge_type = models.CharField(verbose_name='收费类型', max_length=10, choices=ChargeType.choices) objects = EnterpriseManager()class Bill(models.Model): enterprise = models.ForeignKey(Enterprise, verbose_name='企业', on_delete=models.CASCADE) year = models.IntegerField(verbose_name='年份') month = models.IntegerField(verbose_name='月份') # month=0表示年度抄表 price = models.DecimalField(verbose_name='单价', max_digits=15, decimal_places=3) unit = models.CharField(verbose_name='单位', max_length=10) amount = models.DecimalField(verbose_name='用量', max_digits=15, decimal_places=3, default=0) total = models.DecimalField(verbose_name='应收金额', max_digits=15, decimal_places=2) 数据库有 组织(Organization)、企业(Enterprise)和账单(Bill)三张表，它们的关系如下： 每个企业可以隶属于一个组织，也可以不隶属于任何一个组织 每个企业可以有按年缴费和按月缴费两种缴费类型，使用charge_type区分 每个企业在同一月份或者同一年度（由缴费类型决定）只能有一条唯一的记录，该特性由业务层限制 测试代码测试场景：获取所有账单数据，并且需要包括他们的企业基本信息，如名称、地址等。 测试是否使用 select_related 函数对查询耗时的影响。 1234567891011121314151617def test_normal(): t1 = time.time() el = [] bill_qs = models.Bill.objects.all() for bill in bill_qs: el.append(bill.enterprise) t2 = time.time() print('Normal &#123;0&#125;'.format(t2 - t1))def test_select_related(): t1 = time.time() el = [] bill_qs = models.Bill.objects.all().select_related('enterprise') for bill in bill_qs: el.append(bill.enterprise) t2 = time.time() print('Select &#123;0&#125;'.format(t2 - t2)) 规模定义假设 N 表示按年缴费和按月缴费的企业数目，即总企业数为 2N，则一年Bill账单总数为 12 x N + N = 13N，即测试代码中 models.Bill.objects.all().count() 返回的值。 结果以下是在Windows 10 64位 / Python3.5 / Django1.10.3 / 内存数据库 所测的数据： N= 1 10 100 1000 10000 Bill Total 13 130 1300 13000 130000 Normal 0.017008 0.157611 1.892831 16.585734 224.317318 Select 0.004504 0.027019 0.310722 2.259590 26.342256 相比 3.7744 5.8333 6.0917 7.3401 8.5154 使用折线图描绘更为直观： 从以上结果可以看成耗时差距随着规模增加越来越大，N大于1000时，两者耗时已不在一个数量级上了。]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在树莓派安装lxml]]></title>
    <url>%2F2017%2F05%2F14%2Finstall-lxml-on-respberry-pi%2F</url>
    <content type="text"><![CDATA[安装和配置是最令人费劲的： 经常在解决一个问题过程又出现另外一个不得不先解决问题，有点像栈(stack)，忘记了最先要解决的问题 网上的解决方法只是一个参考，时间和环境不一定一样，需要自己去阐释 Google搜索/Bing搜索/stackoverflow是搜索的利器，错误信息一复制粘贴基本上可以找到一些结果，当然和搜索技巧也是有很大关系的 本文记录在树莓派安装lxml的过出现的一些问题和解决方案，本来lxml安装过程比较简单，安装依赖和pip安装两条命令即可。但是由于各种各样的状况和环境导致这过程花费的时间有点长。 12$ sudo apt-get install libxml2-dev libxslt-dev python-dev$ sudo pip3 install lxml lxml的标准安装过程 安装python3.6树莓派3默认安装的是python3.4，版本有点旧，决定自己安装python3.6，从官网下载源代码并自己编译，步骤如下： 1234567wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgztar xvf Python-3.6.1.tgzcd Python-3.6.1./configure --enable-optimizationsmakesudo make altinstallpython3.6 安装完后python3.6路径为 /usr/local/bin/python3.6，另外使用软连接将python3指向3.6， 12sudo ln -s -f /usr/local/bin/python3.6 /usr/local/bin/python3sudo ln -s -f /usr/local/bin/python3.6 /usr/bin/python3 问题: py3clean: permission denied由于安装python3.6没有完全配置好，导致使用apt-get安装任何包都会出现这个错误信息。从字面上是权限的问题，使用chmod命令或者root用户也无效。 后来定位并查看该执行文件的内容,发现是一个python脚本。问题出现在第一行的linux shabang符号，需要 将 #! /usr/bin/python3 改成 #! /usr/local/bin/python3，同时修改的还有同义目录下的py3compile脚本。 123456pi@raspberrypi:~ $ which py3clean/usr/bin/py3cleanpi@raspberrypi:~ $ sudo nano /usr/bin/py3clean GNU nano 2.2.6 File: /usr/bin/py3clean#! /usr/bin/python3 问题：找不到libxslt-devlibxml2-dev包很快就安装成功了，但是libxslt-dev包却却提示找不到。 12345pi@raspberrypi:~ $ sudo apt-get install libxslt-develReading package lists... DoneBuilding dependency treeReading state information... DoneE: Unable to locate package libxslt-devel 在Debian源找到了 libxslt-devel2 包页面，地址是 https://packages.debian.org/jessie/libxml2-dev ，按照页面提示添加apt源并安装。 1W: GPG error: http://ftp.cn.debian.org jessie Release: The following signatures couldn&apos;t be verified because the public key is not available: NO_PUBKEY 8B48AD6246925553 NO_PUBKEY 7638D0442B90D010 NO_PUBKEY CBF8D6FD518E17E1 该消息显示这个源未经过验证，所以需要添加plublic key到系统中，如果显示 imported 1 字样就是导入成功了. 123456pi@raspberrypi:~ $ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 8B48AD6246925553Executing: gpg --ignore-time-conflict --no-options --no-default-keyring --homedir /tmp/tmp.5TjGyQBYus --no-auto-check-trustdb --trust-model always --keyring /etc/apt/trusted.gpg --primary-keyring /etc/apt/trusted.gpg --keyserver keyserver.ubuntu.com --recv-keys 8B48AD6246925553gpg: requesting key 46925553 from hkp server keyserver.ubuntu.comgpg: key 46925553: public key &quot;Debian Archive Automatic Signing Key (7.0/wheezy) &lt;ftpmaster@debian.org&gt;&quot; importedgpg: Total number processed: 1gpg: imported: 1 (RSA: 1) 使用apt安装libxslt-dev。 123456pi@raspberrypi:~ $ sudo apt install libxslt-devReading package lists... DoneBuilding dependency treeReading state information... DoneNote, selecting &apos;libxslt1-dev&apos; instead of &apos;libxslt-dev&apos;... 另外要说的是apt源如果连接不上，树莓派直接死机，使用局域网扫描工具没找到树莓派设备，这个问题也困扰了好几天，没找到直接的解决方法（比如跳过或者设置超时），最后直接注释。 成功安装最后使用pip3安装，大功告成！ 12345678910pi@raspberrypi:~ $ sudo pip3 install lxmlCollecting lxml Using cached lxml-3.7.3.tar.gzBuilding wheels for collected packages: lxml Running setup.py bdist_wheel for lxml ... done Stored in directory: /root/.cache/pip/wheels/df/32/5f/0acd510ac7d66ebe5f35155508972fa732ec45acd5f79146d2Successfully built lxmlInstalling collected packages: lxmlSuccessfully installed lxml-3.7.3]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>lxml</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高德地图热力图和设备监测]]></title>
    <url>%2F2017%2F04%2F29%2Famap-heatmap%2F</url>
    <content type="text"><![CDATA[A 热力图热力图以高亮形式显示数据密集程度。根据密集程度的不同，图上会呈现不同的颜色，以直观的形式展现数据密度。 在设备检测领域，采用热力图可以直观地显示哪些区域的设备具有很高的报警率，为监控决策和提前介入提供了数据依据。 AMap.Heatmap 是高德地图热力图插件，基于heatmapjs。高德地图API引用了heatmap.js最新版本v2.0，v2.0基于新的渲染模型，具有更高的渲染效率和更强的性能。支持chrome、firefox、safari、ie9及以上浏览器。 B 后端数据API根据热力图的文档，后端API需要返回的数据格式如下： 12345678910111213141516[ &#123; "device_serial": "F023D02900010002", "lng": 119.368489, "lat": 25.729161, "address": "XXX", "count": 830 &#125;, &#123; "device_serial": "F023D02900010003", "lng": 119.53378, "lat": 26.206372, "address": "XXX", "count": 220 &#125;] 总体为一个列表，每个元素表示一个设备，包括了设备序列号、设备经纬度、地址和报警数目。其中 lng 、 lat 和 count 是必要的数据，其他两个是可选的。 C 页面布局设计页面布局包括两大部分： 地图控件(div#id_map_container)，放置地图的控件，必须设置其高度。 时间选择器， 使用 position: absolute;z-index: 2;等样式，将时间段选择控件(div#id_time_radio_panel)以绝对定位方式放置在地图控件的右上角。 最外层使用Bootstrap Panel作为容器，并实现了折叠(collapse)效果。 时间选择器只提供了 “最近一年”和“全部”两个时段，时间段太短数据量偏少，不具有很好的代表性。 12345678910111213141516171819202122232425&lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;strong&gt;报警区域分布图&lt;/strong&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div id="id_map_container" style="height: 655px;"&gt; &lt;div id="id_time_radio_panel" class="panel panel-default" style="position: absolute;width:23%;z-index: 2;top:5px;right: 5px;"&gt; &lt;div class="panel-heading"&gt; &lt;a data-toggle="collapse" href="#id_time_radio"&gt;时间段设置&lt;/a&gt; &lt;/div&gt; &lt;div id="id_time_radio" class="collapse in"&gt; &lt;div class="panel-body"&gt; &lt;input type="radio" name="timeDelta" value="365d" checked/&gt;最近一年&amp;nbsp; &lt;input type="radio" name="timeDelta" value=""/&gt;全部时间 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; D js实现主要步骤如下： 首先引入高德地图js库文件，使用注册好的API KEY。 通过 isSupportCanvas 判断是否支持canvas，否则提示相关信息。 创建地图对象，并初始化工具插件。 编写时间选择器切换响应函数，在函数中请求远程数据，并渲染热力图层。 setDataSet 除了数据链表外，还需要设置热力图数值最大最小值。 渲染完成后将地图移动到数值最大的点上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function loadHeatmapData() &#123; var heatmap; $.get('/api/alarm/heatmap/?timeDelta=' + $("input[name=timeDelta]:checked").val(), function (data) &#123; gMapObj.plugin(["AMap.Heatmap"], function () &#123; //初始化heatmap对象 heatmap = new AMap.Heatmap(gMapObj, &#123; radius: 20, opacity: [0, 0.8] &#125;); var maxVal = 0, minVal = 10000; var cIndex = -1; for (var i = 0; i &lt; data.length; i++) &#123; if (data[i].count &gt; maxVal) &#123; maxVal = data[i].count; cIndex = i; &#125; if (data[i].count &lt; minVal) &#123; minVal = data[i].count; &#125; &#125; heatmap.setDataSet(&#123; data: data, max: maxVal, min: minVal &#125;); if (cIndex &gt; -1) &#123; gMapObj.setCenter(new AMap.LngLat(data[cIndex].lng, data[cIndex].lat)); &#125; &#125;); &#125;);&#125;function isSupportCanvas() &#123; var elem = document.createElement('canvas'); return !!(elem.getContext &amp;&amp; elem.getContext('2d'));&#125;var gMapObj = new AMap.Map("id_map_container", &#123; zoom: 15&#125;);AMap.plugin(['AMap.ToolBar', 'AMap.Scale'], function () &#123; gMapObj.addControl(new AMap.ToolBar()); gMapObj.addControl(new AMap.Scale()); gMapObj.addControl(new AMap.OverView());&#125;);if (!isSupportCanvas()) &#123; alert("'热力图仅对支持canvas的浏览器适用,您所使用的浏览器不能使用热力图功能,请换个浏览器试试");&#125; else &#123; loadHeatmapData(); $(":radio").click(function () &#123; loadHeatmapData(); &#125;);&#125; E 示例这是系统经过一个月运行后生成的热力图，虽然数据量还是偏少，但设备之间还是有很好的区分度，比如国惠大酒店旁的设备报警次数就比其他多了几个等级。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
        <tag>Javascript</tag>
        <tag>高德地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python项目持续集成与包发布]]></title>
    <url>%2F2017%2F04%2F25%2Fpython-project-ci-publish%2F</url>
    <content type="text"><![CDATA[本文依据《Python Packaging User Guide (Python打包用户手册)》，以 ConfStruct 为例子描述了Python项目的持续集成和包发布等开发流程，并了解 Travis CI、wheel和twine等工具的使用。 ConfStruct是一个使用类似ORM声明式描述特定场景下的协议数据结构，并提供Python对象和二进制数据之间的转化的Python库。该库解决了使用若干个“类型-长度-值”无序二进制片段传输字典的问题。 主要步骤 准备项目代码 运行本地单元测试 Travis持续集成 编写setup.py文件 生成wheel安装包 发布到PyPI 添加徽章 1 准备项目代码首先准备好项目代码和文本，包括： 源代码 完全通过的测试用例代码 requirements.txt依赖文件 .gitignore文件 [可选] README文件 [可选] 开源协议文件 2 运行本地单元测试依据开发规范，测试代码放置在tests包下，每个测试文件以test_开头。Python的测试框架有： unittest pytest nose tox 本博客使用的是最简单自带的unittest。执行以下命令以运行测试用例。 1python -m unittest discover 结果如下，完全测试通过。 123456E:\projects\ConfStruct&gt;python -m unittest discover.......----------------------------------------------------------------------Ran 7 tests in 0.002sOK 3 Travis持续集成Travis是一个在线持续集成的平台，支持github登录。 第一步，在项目根目录下创建 .travis.yaml文件，写入相关配置。 123456789language: pythonpython: - "2.7" - "3.4" - "3.5" - "3.6"install: - pip install -r requirements_dev.txtscript: python -m unittest 该.travis.yaml文件表明ConfStruct项目需在python2.7和python3.4+环境下使用unittest进行单元测试，测试环境使用不同的依赖文件requirements_dev.txt。 第二步，在github创建一个空项目。并使用github登录Travis,打开这个项目的自动构建开关，每当有新的push或者PR时就会自动触发，并给出是否构建成功的消息。 第三步，使用git将本地代码上传到github，过一两分钟后可在Travis查看相关构建信息，下面是构建成功的结果： 4 编写setup.py文件使用 setuptools来分发写好的模块。在项目目录下新建一个setup.py，主要内容类似如下： 12345678910111213141516171819202122232425262728293031from __future__ import unicode_literalsfrom setuptools import setuplib_classifiers = [ &quot;Development Status :: 4 - Beta&quot;, &quot;Programming Language :: Python :: 2&quot;, &quot;Programming Language :: Python :: 2.7&quot;, &quot;Programming Language :: Python :: 3&quot;, &quot;Programming Language :: Python :: 3.4&quot;, &quot;Programming Language :: Python :: 3.5&quot;, &quot;Programming Language :: Python :: 3.6&quot;, &quot;Intended Audience :: Developers&quot;, &quot;License :: OSI Approved :: MIT License&quot;, &quot;Topic :: Software Development :: Libraries&quot;, &quot;Topic :: Utilities&quot;,]setup(name=&quot;ConfStruct&quot;, version=&apos;0.5.0&apos;, author=&quot;kinegratii&quot;, author_email=&quot;kinegratii@gmail.com&quot;, url=&quot;https://github.com/kinegratii/ConfStruct&quot;, keywords=&quot;struct binary pack unpack&quot;, py_modules=[&quot;conf_struct&quot;], install_requires=[&apos;six&apos;], description=&quot;A parser and builder between python objects and binary data for configure parameters.&quot;, license=&quot;MIT&quot;, classifiers=lib_classifiers ) setuptools.setup 函数，它描述了项目的一些基本信息，主要参数如下表 名称 描述 name 名称，PyPI的唯一标识，不能与已有的冲突。 version 版本字符串，可以使用常量或者从库的 __VERSION__ 导入。 author 作者 author_email 邮箱 url 项目主页 py_modules 源代码模块 install_requires 安装依赖，格式与requirements.txt相同 license 开源协议类型，如 MIT lib_classifiers 分类标签，设置Python版本支持、操作系统支持、面向开发者或使用者、软件分类等信息。可用的选项在这里 可以找到 5 生成wheel安装包wheel 实际上是一个zip压缩包，是Python最新标准分发格式，用于替代eggs。和源代码编译相比，安装wheel无需经过 构建 这个流程，对于终端使用用户来说速度有了实质上的提升。 在使用之前需要安装相关包，运行命令 pip install wheel 即可。 wheel包按照是否纯Python包和23兼容性可分为三种，每种包所需运行的命令和生成的文件名称也有所不同。 Universal Wheels：纯Python，无C扩展；直接(natively)支持Python2和Python3，通常会使用 six 、futures等兼容库或者 __future__ 模块。 Pure Python Wheels：纯Python，无C扩展；无法直接支持Python2和Python3，需要通过 2to3 工具转化 Platform Wheels：针对特定的平台模块，通常是因为需要包含已编译的扩展。 除了第一种Universal Wheels使用以下命令： 1python setup.py bdist_wheel --universal 而 Pure Python Wheels 和 Platform Wheels无需添加 --universal 选项，该命令会检测是否是纯Python包。 1python setup.py bdist_wheel 在这里要发布的是 Universal Wheels，需要添加 --universal 选项。 运行后在dist目录下多了个 ConfStruct-0.5.0-py2.py3-none-any.whl 安装包，使用pip install 命令即可安装成功。根据 PEP425 该安装包文件名遵守这样的规定： 1&#123;distribution&#125;-&#123;version&#125;(-&#123;build tag&#125;)?-&#123;python tag&#125;-&#123;abi tag&#125;-&#123;platform tag&#125;.whl 6 发布到PyPIPyPI目前有两个可用的网址: 旧版 PyPI https://pypi.python.org/pypi 新版 Warehouse https://pypi.org/。Warehouse目前还处于开发状态(pre-production developement)，可以显示项目页面，但是页面内容简单，很多链接还是处于不可用状态。 twine 是一个专门用于发布项目到PyPI的工具，可以使用 pip install twine 来安装，它的主要优点： 安全的HTTPS传输 上传过程中不要求执行setup.py脚本 上传已经存在的文件，支持在发布前进行分发测试 支持任意包格式，包括wheel 最新版本的twine无需注册这一步骤，可直接上传，执行命令 twine register 将显示 HTTPError: 410 Client Error: This API is no longer supported, instead simply upload the file. for url: https://upload.pypi.org/legacy/的错 上传命令如下，在此过程中可能需要输入PyPI的用户名和密码，当然也可以使用 .pypirc 文件来避免多次输入。。 123456twine upload dist/*Uploading distributions to https://upload.pypi.org/legacy/Enter your username: kinegratiiEnter your password:Uploading ConfStruct-0.5.0-py2.py3-none-any.whl[================================] 4259/4259 - 00:00:08 当上传新版本时，最好指定新版本的安装包文件，如 twine upload dist/ConfStruct-0.6.0-py2.py3-none-any.whl，否则会出现文件已存在的错误。 7 添加徽章在 https://badge.fury.io 中输入项目名称并查找，把markdown格式复制到README.md文件。 点击Travis控制台build pass 图片并复制图片链接到README.md。如 12![travis](https://travis-ci.org/kinegratii/ConfStruct.svg?branch=master)[![PyPI version](https://badge.fury.io/py/ConfStruct.svg)](https://badge.fury.io/py/ConfStruct) 效果图]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>测试</tag>
        <tag>构建</tag>
        <tag>PyPI</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Construct：二进制数据解析器和构建器]]></title>
    <url>%2F2017%2F04%2F07%2Fconstruct-python-binary-parse-build%2F</url>
    <content type="text"><![CDATA[Construct是一个强大的二进制数据解析和构建Python库，适用于建立大型复杂应用程序的通信协议，类似于二进制数据的ORM库。 1 标准库structstruct是用于二进制数据的解析和构建，处理Python对象和二进制数据之间的转化。它的API非常简单： stricut.pack(fmt, v1, v2, *) 打包，Python对象到二进制数据 struct.unpack(fmt, buffer) 解包，二进制数据到Python对象 struct.calcsize(fmt) 计算格式字符串数据大小 2 Construct库在开发大型应用程序中，比如实现NMS协议，直接使用 struct 模块需要写大量的代码。和数据库访问库相类比， struct 相当于 mysql-python 底层连接的角色。 - 二进制数据 数据库访问 ORM ? Django ORM / sqlalchemy Connection struct mysql-python / pysycopg2 在 Pypi 使用 “struct + binary” 搜索相关Python库，比较后，Construct是比较合适： github star数目为287 开发活跃，最新发布版本是2.8.11，时间2017-04-05。 支持Python3.6。 文档完备。 按照文档要求下载、安装、测试，基本上符合大部分需求。 声明式定义 使用 Struct 类定义数据结构。 12345678910&gt;&gt;&gt; format = Struct(... &quot;signature&quot; / Const(b&quot;BMP&quot;),... &quot;width&quot; / Int8ub,... &quot;height&quot; / Int8ub,... &quot;pixels&quot; / Array(this.width * this.height, Byte),... )&gt;&gt;&gt; format.build(dict(width=3,height=2,pixels=[7,8,9,11,12,13]))b&apos;BMP\x03\x02\x07\x08\t\x0b\x0c\r&apos;&gt;&gt;&gt; format.parse(b&apos;BMP\x03\x02\x07\x08\t\x0b\x0c\r&apos;)Container(signature=b&apos;BMP&apos;)(width=3)(height=2)(pixels=[7, 8, 9, 11, 12, 13]) 组合和继承 Construct 支持原子结构和自定义结构的组合。使用 Adapter 自定义，下面为4字节存储IPv4数据的解决方案。 1234567&gt;&gt;&gt; class IpAddressAdapter(Adapter):... def _encode(self, obj, context):... return list(map(int, obj.split(&quot;.&quot;)))... def _decode(self, obj, context):... return &quot;&#123;0&#125;.&#123;1&#125;.&#123;2&#125;.&#123;3&#125;&quot;.format(*obj)...&gt;&gt;&gt; IpAddress = IpAddressAdapter(Byte[4]) 使用方法 1234&gt;&gt;&gt; IpAddress.parse(b&quot;\x01\x02\x03\x04&quot;)&apos;1.2.3.4&apos;&gt;&gt;&gt; IpAddress.build(&quot;192.168.2.3&quot;)b&apos;\xc0\xa8\x02\x03&apos;]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>ORM</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NMS协议包识别引擎]]></title>
    <url>%2F2017%2F04%2F02%2Fthe-design-of-packet-identify-engine%2F</url>
    <content type="text"><![CDATA[基于工厂模式的包识别引擎设计，和一般工厂模式不同是： 匹配规则查询表中是一个树形结构，既有精确规则，又有模糊规则，匹配的过程需要多次查询的操作，从精确到模糊直至无法匹配。 匹配规则查询表能够支持添加新规则操作 1 问题描述A NMS基础协议 NMS是服务器与硬件设备(具体为RTU或者网关)工作的通信协议，协议格式描述如下： 网关地址 节点地址 源类型 包序号 包类型 负载长度 负载 gateway_mac rtu_mac source_type packet_id packet_type payload_length payload 8 8 1 4 1 1 - 前23字节为包头部，各个字段描述如下： 网关地址：64位长整型，显示为十六进制形式。 节点地址：64位长整型，显示为十六进制形式。 源类型：表示哪一种设备，主要有 Gateway/GPRS-RTU/Mesh-RTU 三种类型的设备。 包序号：32位整数，0 - 4294967295 。 包类型：该包的类型。 负载长度：整数0-255，表示后面的负载长度，实际中负载长度小于255。 源类型取值定义如下： 设备分类 设备类型取值 描述 网关 0x03 自组网网关 0x06 以太网网关 Mesh-RTU 0x01 自组网RTU，通过自组网关与服务器相连 GPRS-RTU 0x02 GPRS-RTU，与服务器直连 web服务器 0x04 由服务器或者上层应用发起 B 应用协议 NMS可承载多种设备应用协议，比如Modbus协议、DTU低功耗设备协议、远程抄表协议等，每个应用协议使用1字节的整数标识，称之为应用类型(app_id)。由于一些类型的包与上层应用无关，所以在设计中，NMS协议头部没有专门的应用类型字段。 它的规则如下： 应用类型存储在payload中，并且位置不一定相同，但由包类型决定，即由packet_type和payload两个参数可计算出具体应用类型数值 在应用协议扩展过程中，属于统一应用协议的设备（网关或节点）既可以使用现有的设备类型取值，也可申请新的设备类型取值。这取决于具体应用场景，比如Modbus协议中，网关设备只起数据转化的功能，可以部署通用网关，设备类型取值为0x03，远程抄表协议中，网关也能响应服务器的动作，申请新的设备类型取值。 在上述描述中，设备类型(source_type)和设备分类(source_catalog)的概念是不一样的。加入上层应用协议后，它们的关系， 设备分类 设备分类取值 设备类型取值 应用协议 描述 网关 gateway 0x03 通用 自组网网关 0x06 通用 以太网网关 0x07 抄表应用(0x01) 网关 … … … Mesh-RTU mesh_rtu 0x01 通用 自组网RTU，通过自组网关与服务器相连 GPRS-RTU gprs_rtu 0x02 通用 GPRS-RTU，与服务器直连 0x08 报警(0x0A) … … … web服务器 - 0x04 - 由服务器或者上层应用发起 以具体到NMS协议， 包类型与应用类型的对应关系（部分）如下： 包类型 取值 是否应用协议相关 是否设备相关 描述 数据包 0x01 是 无 设备自动上报的数据 心跳包 0x04 否 设备分类相关 维持在线状态 时间同步包 0x06 否 否 由服务器发送 问题： 设计基于树结构的包结构体系。 实现给定一段符合格式NMS的包二进制字节数组，识别所对应的包种类，返回实例化的包对象。 支持扩展已有的应用协议。 2 基本识别过程基于(packet_type, source_type, app_id)的识别引擎主框架代码如下。 packet.py 12345678910111213141516class PacketBase(object): packet_type = None source_catalog = None source_type = None app_related = False app_id = None def __init__(self, gateway_mac, rtu_mac, source_type, packet_id, packet_type, payload_length, payload, **kwargs): self.gateway_mac = gateway_mac self.rtu_mac = rtu_mac self.source_type = source_type or self.source_type self.packet_id = packet_id self.packet_type = packet_type or self.packet_type self.payload_length = payload_length self.payload = payload engine.py 12345678910111213141516171819202122232425262728import structclass AppProtocolBase(object): app_id = Noneclass Engine(object): def __init__(self): self._packet_lookup = &#123;&#125; # 包类对象查询表，为(packet_type, source_type, app_id)到包类对象的映射 self._protocol_lookup = &#123;&#125; def register_protocol(self, protocol_class): pass def add_lookup_item(self, packet_type, source_catalog, source_type, app_id, packet_class): # 添加匹配规则 pass def identify(self, packet_binary): header, payload = packet_binary[:23], packet_binary[23:] gateway_mac, rtu_mac, source_type, packet_id, packet_type, payload_length = struct.unpack('&gt;QQBIBB', header) cls = self._identify_class(packet_type, source_type, payload) if cls: return cls(gateway_mac, rtu_mac, source_type, packet_id, packet_type, payload_length, payload) def identify_class(self, packet_type, source_type, payload): # 输入为包索引(packet_type, source_type, app_id) # 在查询过程中，可能需要经过精确到模糊的查找过程，并不是简单的 dict.get 调用 pass 3 查询表(lookup)3.1 构建基本查询表包索引即为查询表中的键 packet.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 构建class DataPacket(PacketBase): packet_type = 0x01 app_related = Trueclass GatewayHeartbeatPacket(PacketBase): packet_type = 0x04 source_catalog = 'gateway'class MeshRTUHeartbeatPacket(PacketBase): packet_type = 0x04 source_catalog = 'mesh_rtu'class GPRSHeartbeatPacket(PacketBase): packet_type = 0x04 source_catalog = 'gprs_rtu'class TimeSyncPacket(PacketBase): packet_type = 0x06 source_catalog = 0x04 def build_lookup(*args): packet_lookup = &#123;&#125; app_related_packet_type_set = &#123;&#125; for packet_class in args: packet_lookup[(packet_class.packet_type, packet_class.source_type or packet_class.source_type, None)] = packet_class if packet_class.app_related: app_related_packet_type_set.add(packet_class.packet_type) return packet_lookup, app_related_packet_type_set# 两个查询表计算过程# PACKET_LOOKUP, APP_RELATED_PACKET_TYPE_SET = build_lookup(# DataPacket,# GatewayHeartbeatPacket,# GPRSHeartbeatPacket,# MeshRTUHeartbeatPacket,# TimeSyncPacket# )# 为了下面示例方面，直接给出最后结果PACKET_LOOKUP = &#123; (0x01, None, None): DataPacket, (0x04, 'gateway', None): GatewayHeartbeatPacket, (0x04, 'gprs_rtu', None): GPRSHeartbeatPacket, (0x04, 'mesh_rtu', None): MeshRTUHeartbeatPacket, (0x06, 0x04, None): TimeSyncPacket&#125;# 所有与应用相关的包类型集合APP_RELATED_PACKET_TYPE_SET = &#123; 0x01 &#125;SOURCE_TYPE_CATALOG_LOOKUP = &#123; 0x01: 'mesh_rtu', 0x02: 'gprs_rtu', 0x03: 'gateway', 0x04: 'gateway'&#125;SOURCE_CATALOG_SET = &#123;'gateway', 'mesh_rtu', 'gprs_rtu'&#125; 3.2 基于应用协议扩展识别规则查询表注册应用协议实际为上述查询表增加了更加精确的匹配规则，当本应用协议的包类对象无法使用才会使用基本的包类对象。在添加匹配规则时： 应用类型：应用类型不能与已有的冲突 包类型：只能注册那些与应用相关的类型的包(类型存储在 APP_RELATED_PACKET_TYPE_SET)，因为与应用无关的包没有存储应用类型字段，识别时无法分发。 源类型和源分类 使用已有的设备分类，对应于若干种设备 使用已有的设备类型 使用新的设备类型，不能和已有的相冲突，同时必须指定设备分类 实现过程如下： 123456789101112131415161718192021222324252627import copyfrom .packet import PACKET_LOOKUP, APP_RELATED_PACKET_TYPE_SET, SOURCE_CATALOG_SET, SOURCE_TYPE_CATALOG_LOOKUPclass Engine(object): def __init__(self): self._packet_lookup = copy.copy(PACKET_LOOKUP) # 包类对象查询表，为(packet_type, source_type, app_id)到包类对象的映射 self._source_type_catalog_lookup = copy.copy(SOURCE_TYPE_CATALOG_LOOKUP) self._protocol_lookup = &#123;&#125; def register_protocol(self, protocol_class): if protocol_class.app_id in self._protocol_lookup: raise ValueError('The app_id value &#123;&#125; in the &#123;&#125; has conflicted!'.format(protocol_class.app_id, protocol_class.__name__)) self._protocol_lookup[protocol_class.app_id] = protocol_class for packet_class in protocol_class.packet_lookup: self.add_lookup_item(packet_class.packet_type, protocol_class.source_catalog, protocol_class.source_type, protocol_class.app_id, protocol_class) def add_lookup_item(self, packet_type, source_catalog, source_type, app_id, packet_class): if packet_type not in APP_RELATED_PACKET_TYPE_SET: raise ValueError('Protocol Register with packet_type &#123;&#125; is not supported!'.format(packet_type)) if source_type in self._source_type_catalog_lookup: self._packet_lookup[(packet_type, source_type, protocol_class.app_id)] = packet_class else: if source_catalog in SOURCE_CATALOG_SET: self._packet_lookup[(packet_type, source_catalog, protocol_class.app_id)] = packet_class else: raise ValueError('Invalid source_catalog') 3.3 使用方法和测试案例123456789101112131415161718class HydrantDataPacket(DataPacket): passclass HydrantProtocol(AppProtocolBase): app_id = 0x0A packet_lookup = &#123; HydrantDataPacket &#125;engine = Engine()engine.register_protocol(HydrantProtocol)payload = struct.pack('&gt;BBBBB', 0x0A, 3, 4, 5, 6)test_binary = struct.pack('&gt;QQBIBB', 70971071088567232, 70971071088567240, 13, 0x01, 5) + payloadpacket = engine.indentfity(test_binary)assert isinstance(packet, HydrantProtocol) == True 4 识别匹配 查询 (packet_tpye, source_type, None) 是：计算app_id，查询(packet_tpye, source_catalog, app_id) 是：使用(packet_tpye, source_catalog, app_id) 否：使用(packet_tpye, source_type, None) 否：当前packet_tpye是否有app_id 是：计算app_id，查询 (packet_tpye, source_catalog, app_id) 是：使用 (packet_tpye, source_catalog, app_id) 否：无法识别 否：查询 (packet_tpye, source_catalog, None) 是：使用(packet_tpye, source_catalog, None) 否：无法识别 12345678910111213141516171819class Engine(object): def identify_class(self, packet_type, source_type, payload) cls = self._packet_lookup.get((packet_type, source_type, None)) if cls: source_type_or_catalog = source_type else: source_catalog = self._source_type_catalog_lookup.get(source_type) cls = self._packet_lookup.get((packet_type, source_catalog, None)) if cls: source_type_or_catalog = source_catalog else: source_type_or_catalog = None if packet_type in APP_PACKET_TYPE_LOOKUP and cls: app_id = cls.parse_app_id() t_cls = self._packet_lookup.get((packet_type, source_type_or_catalog, app_id)) if t_cls: cls = t_cls return cls]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习（一） —— 准备工作]]></title>
    <url>%2F2017%2F03%2F29%2Fstart-machine-learning%2F</url>
    <content type="text"><![CDATA[使用Python开发web已经有一两年的时间了，是时候在业余时间接触下其他领域了。Python被称为“胶水语言”，在各个领域都占有一席之地，除了web开发之外，近年来在人工智能/机器学习也得到了广泛的应用。随着信息技术的不断发展，人工智能/机器学习也越来越受到欢。另一方面和web开发不同的是理论研究在机器学习中占有很大的比重。 入门资料在决定入机器学习这个领域，自己也大致搜索了各方面的资料，从以下教程入门，网上也有相关的电子资源。 《离散学习机器应用（原书第6版）》：图论、命题逻辑 《algorithms-in-python》：Python的算法书 《数据科学入门》：线性代数、统计概率等一些基础知识 《Python科学计算》：numpy等包的使用 《机器学习实战》：基于Python的各种算法实现 《机器学习导论》：理论阐述 昨晚刚读完《机器学习实战》第二章有关k近邻算法的内容，感觉这本书对于理论部分讲述的很少，后来又找来了《机器学习导论》这本书，两本书一起看，理论和实践相结合，应该会发挥更好地效果。 库安装Python3下安装一些基本库就比较简单了，matplotlib和numpy都可以用pip命令安装。 后记这是万里旅行的第一步，谨此记录，期许有个美好的开始。]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSC乱弹歌曲列表]]></title>
    <url>%2F2017%2F02%2F13%2Fosc-daily-blog-music%2F</url>
    <content type="text"><![CDATA[OSC乱弹歌曲列表，爬虫源码：https://git.oschina.net/kinegratii/codes/hjug0mlicztve9yd18xn553 보여줄게（给你看） - Ailee 风再起时 - 张国荣 風になる - つじあやの 青春贵族 - 中村雅俊 难得 - 安来宁 闷 - 王菲 锤子之歌 - 菠萝橙 追梦赤子心 - GALA 这么近那么远 - 张学友 身骑白马 - 徐佳莹 被风吹过的夏天 (Live) - live林俊杰/金莎 行かないで - 玉置浩二 给自己的情书 - 王菲 终于等到你 - 张靓颖 纷飞(live版) - 徐怀钰 童话镇 - 陈一发儿 百恋歌 - 高杉さと美 白色球鞋 - 陈奕迅 玫瑰花的葬礼 - 许嵩 猫になりたい - つじあやの 爱情 - 郭富城 温柔 (2013混音版) - 五月天 深海少女 - nero/ゆう十 深い森（TV动画《犬夜叉》片尾曲 第二弹） - Do As Infinity 流川枫与苍井空 - 黑撒 流れ星（小幸运 (日语版)） - 荒木毬菜 泣けない君へのラブソング - 前田亘辉 河 - 张雨生 極楽浄土 - GARNiDELiA 梦回唐朝 - 唐朝 月光下的凤尾竹 - 葫芦丝 暗涌 - 王菲 春风十里 - 鹿先森乐队 春风十里 - 鹿先森乐队 散了吧 - 林志炫 摄影艺术 - 许嵩 我们的歌 - 王力宏 情人 - 许巍 思ひで（深夜食堂 片头曲） - 鈴木常吉 幻听 - 许嵩 幸福的旁边 - 花儿 娃娃脸 - 后弦 好久不见 - 张学友 天空之城 - 李志 大鱼（动画电影《大鱼海棠》印象曲） - 周深 吻得太逼真 - 张敬轩 南方姑娘 - 赵雷 十二楼 - 杨宗纬 初恋 - 玉置浩二 刚刚好 - 薛之谦 分手快乐 - 冰淇 光辉岁月 - Beyond 你还要我怎样 - 薛之谦 为爱痴狂 (Live) - 刘若英 一辈子的孤单 (Live)（电视剧《涩女郎》片尾曲） - 刘若英 一起走过的日子 (粤)（电影《至尊无上Ⅱ之永霸天下》主题曲） - 刘德华 一剪梅（电影《夏洛特烦恼》主题曲） - 黄渤/左小祖咒 ムーンライト伝説（テレビアニメ『美少女戦士セーラームーン』オープニングテーマ主題歌） - Dali ポケットにファンタジー - じゅり ハーフムーン・セレナーデ（月半小夜曲） - 河合奈保子 ニッポン笑顔百景（TV动画《女子落语》ED / TVアニメ『じょしらく』EDテーマ） - 桃黒亭一門 スカイクラッドの観测者 - いとうかなこ グッバイ・デイ - 来生たかお おくりびと~on record~ - 久石譲 いつも何度でも(主题歌) - 木村弓 あなただけ见つめてる - 大黒摩季 《어디부터 어디까지》- 泫雅/梁耀燮 《너에게》- 成时京 《閃光の行方》- 小寺可南子 《铁血丹心》- 罗文/甄妮 《那么骄傲》- 金海心 《遇见》- 言叶之庭 《追梦赤子心》- GALA 《路过蜻蜓》- 林忆莲 《贝加尔湖畔》- 李健 《请不要对我说sorry》- 何洁 《苦笑》 - 汪苏泷 《花香》- 林志炫 《终身美丽》- 郑秀文 《离歌》- 信 《神啊，救救我》- 陈小春 《相守》- 栗先达 《生如夏花》- 朴树 《理想三旬》- 陈鸿宇 《牡丹江》- 南拳妈妈 《爱你十分泪七分》 - 裘海正 《烟花三月(烟花三月XRCD)》- 童丽 《海の见える街》- 久石让 《泪海》- 徐茹芸 《没有舍不得》- 花漾年华 《朋友的酒》 - 李晓杰 《曲终人散》- 张宇 《春季自救指南》 - 上海彩虹室内合唱团 《星降る夜のリストランテ》- コーコーヤ 《明日への鼓動》- 小寺可南子 《无までの30分》- andymori 《文学少女で“文学少女”》 - Audio Highs 《我知道你很难过》- 蔡依林 《我梦见我梦见我》- 本兮 《我不要被你记住》- 周柏豪 《愿(Live) - live》- 莫文蔚 《家》- 许巍 《好久不见》- 陈奕迅 《太多》- 陈冠蒲 《夢のつづき》- 玉置浩二 《啜泣》- 李克勤 《南山南》- 马頔 《勇敢一点》- 薛之谦 《分裂(离开)》- 周杰伦 《冬天不会再冷》- 徐盼. 《再等几天 (Live)》- 陈奕迅 《其实我不快乐》- 钟嘉欣 《低回》- 杨宗纬 《东京不太热》- 洛天依 《一生所爱 》- 舒淇 《一生守候》 - 王若琳 《ただひたすらに、前へ》 - Falcom Sound Team jdk 《warriors》- Imagine Dragons 《secret base》- 茅野愛衣 / 戸松遥 / 早見沙織 《dream it possible》- Delacey 《Young And Beautiful》 - Lana Del Rey 《What Are Words》- Chris Medina 《We Don’t Talk Anymore (原唱：Charlie Puth)》- 莫文蔚 《Victory》- Two Steps From Hell 《Turnin’》- Young Rising Sons 《Today My Life Begins》 - Bruno Mars 《To Be Free》 - 华晨宇 《Stay Gold》- 大橋トリオ 《Some Dreams》- Allan Taylor 《Ring Off The Hook》- w-inds 《Radioactive》- William Joseph 《Por Una Cabeza (一步之遥)》- Elvins.J 《Parachute》- Sean Lennon 《PG家长指引(Live) - live》- 陈奕迅 《One more time, One more chance》- 山崎まさよし 《No ones saves us but ourselves》- Kraddy 《Love Is A Waste Of Time》- Sonu Nigam / Shreya Ghoshal 《Kong》- 侧田 《Jenny》- Robert de Boron / Daichi Diez / Shaira 《I Hate myself for loving you》- Joan Jett 《I Am You》- Kim Taylor 《Hotel California》- Eagles 《Fade(钢琴版)》- 马里奥赛德 / Alan Walker 《Eyes On Me》- 王菲 《Closer》- The Chainsmokers/Halsey 《Christmas Lights》- Coldplay 《California Dreaming (重庆森林)》- The Papas / The Mamas 《&nbsp;神经病之歌 》- 洛天依 / 言和 《 時の過ぎゆくままに 》- 沢田研二 《 みちゆき 》- 引田香織 sugar - Maroon 5 Young For You - GALA Yellow - Coldplay What Makes You Beautiful - One Direction Viva La Vida - Coldplay There You’ll Be (Album Version)（电影《珍珠港》片尾曲） - Faith Hill TO BE - 浜崎あゆみ Somebody That I Used To Know - Gotye/Kimbra Sledgehammer (From The Motion Picture “Star Trek Beyond”)（ 电影《星际迷航3：超越星辰》主题曲） - Rihanna Simple Life - Young Rising Sons Shots (feat. Broiler) [Broiler Remix] - Imagine Dragons / Broiler Shots (feat. Broiler) [Broiler Remix] - Imagine Dragons / Broiler Roads - Portishead PG家长指引(Live) - live - 陈奕迅 Opening - 黄英华 One Night In 北京 - 信乐团 Numb - Linkin Park Mariage d’amour（梦中的婚礼） - 理查德.克莱德曼 Maps - Maroon 5 Lost stars - Keira knightley Je m’appelle Hélène（我的名字叫伊莲） - Hélène Rolles It’s only the fairy tale - 宮村優子 I Am You - Kim Taylor Hymn For The Weekend [Remix] - Alan Walker/Coldplay Hey, Soul Sister - Train Here We Are （电影《使徒行者》主题曲） - 华晨宇 Hello World - Lady Antebellum HTML - The Hot Toddies HTML - The Hot Toddies Gate of steiner -piano- 阿保剛 GRACE KELLY - 大橋トリオ Dearest - 浜崎あゆみ Counting Stars - OneRepublic Cheapest Flight - PREP Bressanone（布列瑟农） - Matthew Lien]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>开源中国</tag>
        <tag>爬虫</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取OSC每日乱弹的音乐]]></title>
    <url>%2F2017%2F02%2F13%2Ffetch-music-of-daily-blog-in-oschina%2F</url>
    <content type="text"><![CDATA[使用aiohttp + lxml/爬取OSC乱弹的歌曲 一 原理分析爬取路径与结果 爬取路径：博客列表 =》 提取博客链接 =》 获取博客内容 =》 提取歌曲信息，最后获取的结果包含了博客链接、博客标题、歌曲链接，歌曲标题的一个列表。1234[ &#123;'blog_url': 'xxx', 'blog_title': 'xxx', 'music_url': 'xxx', 'music_title': 'xxx'&#125;, &#123;'blog_url': 'xxx', 'blog_title': 'xxx'&#125;,# 该博客歌曲提取失败] 起点url 爬取的起点url为博客列表的页面链接。1https://my.oschina.net/xxiaobian/blog?catalog=547834&amp;sort=time&amp;p=&#123;page&#125; 其中page表示页码，范围取值为1-24,25页之后的乱弹就没有网易云音乐的歌曲了。 歌曲链接 歌曲链接的格式为：http://music.163.com/#/song?id=5038302或者http://music.163.com/#/song/187747/，可归纳为以http://music.163.com/#/song开头的均符合要求。 歌曲标题 首先在博客中查找。歌曲标题通常为 - 分割的一整个段落，表示歌曲和歌手。比如最新博客使用“单独段落+书名号”（如&lt;p&gt;《Victory》- Two Steps From Hell&lt;p&gt;）这种就比较好匹配，没有书名号的就很少能够提取到。 在博客文档中无法找到（通常是由于匹配规则无法覆盖所有情况），向云音乐网站获取数据，注意两点： 需要将 http://music.163.com/#/song?id=28285557 转换成 http://music.163.com/song?id=28285557 格式 网页标题去掉末尾的字符串“- 网易云音乐”即是所需要的歌手歌曲信息。 二 实现协程并发执行 程序的核心利用协程实现并发执行，和多线程不同，所有代码都在一个线程执行，减少上下文切换，无需要线程之间的锁机制，效率可大大提高。 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。 —— 《协程 - 廖雪峰的官方网站》 程序主要使用了以下几个库： asyncio：Python3标准库，异步IO， aiohttp:异步HTT库，类似于requests的异步实现 lxml：html解析，使用xpath语法 re：正则表达式 按照aiohttp的文档将每一个HTTP请求和内容解析都包装成一个协程函数： fetch_music_title(song_url)获取歌手歌曲信息 fetch_music(blog_url) 获取歌曲信息 fetch_blog_list(page) 获取博客列表 根据逻辑将这三个协程包裹新的协程fetch_page_music(page)，用于获取每一页博客中的歌曲信息列表。程序运行时，为每一页创建一个fetch_page_music协程并放进事件循环，待所有协程执行完整后处理相关数据并显示。 代码注释 loop.run_until_complete() 返回值为各个协程函数的返回值组成的列表 //a[@class=&quot;blog-title&quot;]表示获取class为blog-title所有a元素 //a[starts-with(@href, &quot;http://music.163.com/&quot;)]表示获取href值以http://music.163.com/ 开头的所有a元素。 itertools.chain.from_iterable(iterable)将数组“压平”，如 [[1,2], [3,4],[5,6]] 返回 [1,2,3,4,5,6] 三 运行原理结果 四 其他源代码 链接：爬取OSC乱弹的歌曲 （要求Python3.5+） 爬取结果 一共爬取了185首歌曲，码云代码片段没有md功能，存自己博客上了，点击访问链接。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>开源中国</tag>
        <tag>异步IO</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript农历库]]></title>
    <url>%2F2017%2F01%2F28%2Ftypescript-calendars%2F</url>
    <content type="text"><![CDATA[本文描述了自己写了一个 Typescript 日历库。 1 数据结构一个日期使用 CalendarDate 类表示，其属性如下： 1234567891011121314151617181920CalendarDate &#123; lYear: 2016, lMonth: 11, lDay: 8, animal: '猴', lMonthCn: '冬月', lDayCn: '初八', sYear: 2016, sMonth: 12, sDay: 6, gzYear: '丙申', gzMonth: '己亥', gzDay: '壬戌', isToday: false, isLeap: false, nWeek: 2, nWeekCn: '星期二', isTerm: false, term: null, astro: '射手座' &#125; 2 创建日期对象1import &#123; CalendarDate,Calendars &#125; from 'calendars'; 2.1 公历转农历使用 Calendars.solar2lunar() 或者 Calendars.fromSolarDate() 从农历日期创建 CalendarDate 对象。 12let date:CalendarDate = Calendars.solar2lunar();date.format('&#123;sYear&#125;年&#123;sMonth&#125;月&#123;sDay&#125;日') // '2016年12月5日' 2.2 农历转公历使用 Calendars.lunar2solar() 或者 Calendars.fromLunarDate() 从农历日期创建 CalendarDate对象。 12let date2:CalendarDate = Calendars.lunar2solar(2017, 6, 1, true); // 2017年农历闰六月初一date.format('&#123;sYear&#125;年&#123;sMonth&#125;月&#123;sDay&#125;日') // '2017年7月23日' 2.3 从通用字符串创建12let date3:CalendarDate = Calendars.fromDateString('2017060111'); // 2017年农历闰六月初一date3.format('&#123;sYear&#125;年&#123;sMonth&#125;月&#123;sDay&#125;日') // '2017年7月23日' 3 工具类3.1 日期间隔123456// 230，距离今天还有230天date2.delta()date2.delta(date)date2.delta(&#123;sYear:2017,sMonth:7,sDay:23&#125;)Calendars.delta(date, date2);Calendars.delta(&#123;sYear:2016,sMonth:12,sDay:5&#125;, &#123;sYear:2017,sMonth:7,sDay:23&#125;) 3.2 日期推算1234567891011//两天之后date2.offset(2)//或date2.after(2)//两天之前date2.offset(-2)//或date2.before(2)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows+django+apache+wsgi项目部署]]></title>
    <url>%2F2016%2F12%2F09%2Fwindows-django-apache-wsgi%2F</url>
    <content type="text"><![CDATA[基本环境 Windows 7 32位 Python 2.7 32位 Django 1.10 Apache 2.2 目录文件位置 名称 文件目录 virtualenv D:/env/dj110/ Django项目目录 D:/nms wsgi.py D:/nms/nms/wsgi.py 静态文件目录 D:/static/nms/ 上传文件目录 D:/upload/nms/ Apache目录 C:/Apache22/ 步骤1 下载 Apache 2.2 32位，并解压至 C:\Apache22\ 。 2 下载mod_wsgi模块文件，将 mod_wsgi 放入 C:\Apache2.2\modules 目录。 3 编写 http.conf 文件。 12345678910111213141516171819202122232425262728293031WSGIPythonPath D:/nms;D:/env/dj110/Lib/site-packages;#----------------------------------------------------------------------#virtual host for nms&lt;VirtualHost *:8020&gt;ServerAdmin test@163.comDocumentRoot D:/nmsAlias /static/ D:/static/nms/Alias /upload/ D:/upload/nms/&lt;Directory D:/static/nms&gt;Order deny,allowAllow from all&lt;/Directory&gt;&lt;Directory D:/upload/nms&gt;Order deny,allowAllow from all&lt;/Directory&gt;WSGIScriptAlias / D:/nms/nms/wsgi.py&lt;Directory D:/nms/nms/&gt;&lt;Files wsgi.py&gt;Order deny,allowAllow from all&lt;/Files&gt;&lt;/Directory&gt;&lt;/VirtualHost&gt; Q&amp;A静态文件404 使用django 的collectstatic 命令将所有的静态文件收集到一个目录下，可以不在Django项目下，然后使用Alias由Apache接管/static/的访问。 静态文件403 Alias /static/ D:/static/nms/中static文件目录最后需要加上目录分隔符 /。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>部署</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic2杂记]]></title>
    <url>%2F2016%2F12%2F02%2Flearning-ionic2%2F</url>
    <content type="text"><![CDATA[1 技能链 Typescript –&gt; Angular2 –&gt; ionic2 ionic2是基于Angular2开发，Angular2是使用Typescript重新改写的。Typescript是Javascript类型的超集。学习之前先列出相关中文文档。 Typescript中文网 Angular2中文文档 ionic2 2 Typescript和Javascript相比，在函数、接口、类、泛型都有很大的变化，总的来说，会使得程序更加明确，加强了面向对象的一些设计规范。 interface是接口，class是类。类可以实现接口。 3 第三方js库与d.ts声明文件对于现有第三方js库，根据不同情况采取不同的策略。 下载d.ts声明文件 自己编写d.ts声明文件 实现对应TypeScript的版本 一些常用库诸如underscope.js可在DefinitelyTyped/DefinitelyTyped下载到对应的d.ts文件。 中国家庭称谓计算器，该项目的接口只有一个顶级函数 relationship，相应的d.ts文件可以自己编写。以下是一种写法。 文件 relationship.d.ts 12345678interface RelationshipOptions &#123; text:string; sex:number; type:string; reverse?:boolean;&#125;declare function relationship(relationshipOptions:RelationshipOptions):string;export = relationship; 调用示例 demo.ts 1234567891011/// &lt;reference path="relationship.d.ts" /&gt;import relationship = require('./relationship');let s = relationship(&#123; text:'爸爸的弟弟', sex:1, type:'default', reverse:true&#125;)console.log(s); //侄子 而项目引用的另一个库《1900年至2100年公历、农历互转Js代码》，API也比较简单，但ionic1项目中对其进行了比较多的扩展（日期加减），因此采用重写自己的Typescript版本。项目地址 https://github.com/kinegratii/ts-calendars。 4 版本与开发IDE目前ionic2版本为rc3，还未发布正式版，但按照版本规律，许多API已经稳定下来了，不像Beta的时候有项目布局那样大的改变，因此可以开始使用和迁移了。 习惯了JetBrain系列的IDE，因此使用WebStorm进行开发，当然是用VS Code也是大家极力推荐的。 5 创建项目ionic2和ionic1相比，项目布局变化比较多，决定重新创建一个项目，不在原有的项目进行更改，使得一开始就符合ionic2的开发规范。 使用下面的命令行创建一个ionic2项目。 1ionic start FamilyApp --v2 默认使用tabs界面，创建了三个页面。 6 页面使用以下命令创建新的页面。 1ionic generate page more 在src/pages/创建以下三个文件。 more/more.html 模板文件 more/more.scss css样式 more/more.ts 组件代码 并且将新页面加入模块app.module.ts文件中。 12345678910@NgModule(&#123; declarations:[ # ... MorePage, ], entryComponents:[ # ... MorePage, ]&#125;) 7 导航习惯先创建所有的页面，完成跳转逻辑，最后再写各个页面的逻辑。 ionic2的导航类似于Android，像一个简单的栈，可以进行push和remove操作。不建议使用url来决定导航，当然从底层也支持这么做。 1no component factory found for AboutPage 在刚使用导航（MorePage -&gt; AboutPage）时出现了这个错误，解决的方案是将AboutPage加到app.module.ts的declarations和entryComponents，两个都要添加。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>ionic</tag>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django实践：数据库查询]]></title>
    <url>%2F2016%2F11%2F18%2Fdjango-models-practice%2F</url>
    <content type="text"><![CDATA[1 概述本文总结了一些Django数据库查询的实践经验。 基本的增删改查 分类统计：aggregate和annotate的使用 实现按年/月/日统计 Manager和QuerySet的混合使用 编写迁移文件 根据Django官方文档，本人整理出与数据库相关的话题列表， 基本的增删改查 外键访问 (Accessing related objects) 管理器和查询集 (Manger &amp; QuerySet) 原生SQL (raw SQL) 事务 (Transactions) 统计、聚合和分组 (Aggregation) 搜索 (Search) 自定义字段 (Custom fields) 多数据库 (Multiple databases ) 查询表达式和自定义查询表达式(Lookup expressions &amp; Custom lookups) 条件表达式 (Conditional Expressions) 数据库函数 (Database Functions) 数据库优化 (Optimize database access) 数据库迁移 (Migrations) 其中一部分是在数据库有对应的内容，另外一部分则是Django框架自有的特性。涉及的代码主要包括以下三个包： django.db.connections: 底层数据库连接对象操作 django.db.migrations: 迁移相关 django.db.models: 模型定义、数据库查询 2 查询API2.1 模型描述以一个设备管理系统的简易系统为例，该项目包含了设备描述和报警记录。 设备以序列号唯一确定该设备，可默认为“主键”。 longitude latitude和address表示设备的地理位置，创建后可认为不可更改。 设备含有使用和报警两个状态标识变量。 Alarm.catalog表示警报类型，定义在choices上。 123456789101112131415161718192021222324252627class Device(models.Model): serial = models.CharField(verbose_name='序列号', max_length=100, unique=True) name = models.CharField(verbose_name='名称', max_length=100, null=True, blank=True) longitude = models.FloatField(verbose_name='经度', null=True, validators=[validators.MaxValueValidator(180), validators.MinValueValidator(-180)]) latitude = models.FloatField(verbose_name='纬度', null=True, validators=[validators.MaxValueValidator(90), validators.MinValueValidator(-90)]) address = models.CharField(verbose_name='地址', max_length=100, null=True) is_active = models.BooleanField(verbose_name='使用标识', default=True) is_alarm = models.BooleanField(verbose_name='报警标识', default=False) latest_alarm_time = models.DateTimeField(verbose_name='最新报警时间', null=True, blank=True) latest_alarm_remark = models.CharField(verbose_name='最新报警内容', max_length=200, null=True, blank=True) def __str__(self): return self.serialclass Alarm(models.Model): ALARM_CATALOG_CHOICES = ( ('low_battery', '低电量'), ('fail_connection', '通信故障'), ('location_moved', '位置移动') ) device = models.ForeignKey(Device, verbose_name='设备') create_time = models.DateTimeField(verbose_name='创建时间', default=timezone.now) catalog = models.CharField(max_length=30, null=True, choices=ALARM_CATALOG_CHOICES) content = models.CharField(verbose_name='内容', max_length=30, null=True, blank=True) read = models.BooleanField(verbose_name='已读', default=False) 2.2 查询一览表2.2.1 检索、过滤、外键查询、分页1234567891011121314151617# 查询mac地址为'0FFFFFFF561C4030'的设备try: device = models.Device.objects.get(serial='0FFFFFFF561C4030')except models.Device.DoesNotExist: device = None&lt;Device:0FFFFFFF561C4030&gt;# 查询地址包含“小区”的设备。&gt;&gt;&gt; device_list = models.Device.objects.filter(address__icontains='小区')&lt;QuerySet [&lt;Device: 0FFFFFFF5BC91F87&gt;, &lt;Device: 0FFFFFFF561C4030&gt;, ...]&gt;# 查询设备'0FFFFFFF5BC91F87'的所有报警记录models.Alarm.objects.filter(device__serial='0FFFFFFF5BC91F87')# 假设设备列表每页20项，查询第3页的数据。device_list = models.Device.objects.all()[20:30] 2.2.2 更新12345678910111213# 单记录更新try: device = models.Device.objects.get(serial='0FFFFFFF561C4030') device.is_active = False device.save()except models.Device.DoesNotExist: pass# 多记录更新models.Device.objects.filter(serial__in=['0FFFFFFF561C4030', '0FFFFFFF56174CA0']).update(is_active=False)# 去掉所有设备地址中“福建省”的前缀，比如“福建省厦门市Xxxx”改为"厦门市Xxxx"。models.Device.objects.filter(address__isnull=False).update(address=F('address').strip('福建省')) 2.2.3 删除123456789101112# 删除单条记录try: device = models.Device.objects.get(serial='0FFFFFFF561C4030') device.delete()except models.Device.DoesNotExist: pass# 批量删除models.Alarm.objects.filter(serial='0FFFFFFF561C4030').delete()# 由于delete只是QuerySet的方法，并没有向Manager公开，需要先调用all方法models.Alarm.objects.all().delete() # OKmodels.Alarm.objects.delete() # Fail 2.2.4 基础统计：数据、最值和平均值12345678910111213141516171819202122# 计算设备0FFFFFFF561C4030所有的报警数目。models.Alarm.objects.filter(device__serial=&apos;0FFFFFFF561C4030&apos;).count()# 165# 计算每个设备的报警数目。&gt;&gt;&gt; device_list = models.Device.objects.annotate(num_alarms=Count(&apos;alarm&apos;))&gt;&gt;&gt; device_list&lt;QuerySet [&lt;Device: 0FFFFFFF561C4021&gt;, &lt;Device: 0FFFFFFF561C4030&gt;, ...]&gt;&gt;&gt;&gt; device_list [0].num_alarms34# 查询2016年报警次数最多的前5个设备models.Alarm.objects.filter(create_time__year=2016).values(&apos;serial&apos;).annotate(num_alarms=models.Count(&apos;serial&apos;)).order_by(&apos;-num_alarms&apos;)[:5][ &#123;&apos;serial&apos;:&apos;0FFFFFFF9FFC15F9&apos;, &apos;num_alarms&apos;:38&#125;, &#123;&apos;serial&apos;:&apos;0FFFFFFF71281152&apos;, &apos;num_alarms&apos;:32&#125;, &#123;&apos;serial&apos;:&apos;0FFFFFFF5992B723&apos;, &apos;num_alarms&apos;:27&#125;, &#123;&apos;serial&apos;:&apos;0FFFFFFF05E20356&apos;, &apos;num_alarms&apos;:21&#125;, &#123;&apos;serial&apos;:&apos;0FFFFFFF66DDF14D&apos;, &apos;num_alarms&apos;:12&#125;,] 2.2.5 分类统计分类统计有以下两种方法。 aggregate + 条件表达式Case，返回一个字典形式的结果，未出现的分类值默认为None，需要使用Coalesce函数设置默认值 annotate + 分组GROUP BY，返回一个列表形式的结果，未出现的分类值不会出现在最后的结果中 下面是两种方式查询最近30天中每个报警类型的报警数目为例。 123456789101112131415161718192021latest_week_qs = models.Alarm.objects.filter(create_time__gt=timezone.now()-timedelta(days=30).# aggregate方式latest_week_qs.aggregate( fail_connection=Coalesce(Sum( Case(When(catalog='fail_connection', then=1), output_field=models.IntegerField()), ), 0), low_battery=Coalesce(Sum( Case(When(catalog='low_battery', then=1), output_field=models.IntegerField()), ), 0), location_moved=Coalesce(Sum( Case(When(catalog='location_moved', then=1), output_field=models.IntegerField()), ), 0))# 结果&#123;‘fail_connection’：12， 'low_battery'：34, 'location_moved': 0&#125;# annotate方式latest_week_qs.values('catalog').annotate(count=Count('catalog'))# 结果[&#123;'catalog':'low_battery', 'count':34&#125;,&#123;'catalog':'fail_connection'， 'count': 12&#125;] 2.2.6 日期统计实现按年、月、日统计通常有两种方法： 数据库函数 django.db.connection.ops.date_trunc_sql 对第一种的封装类DateExtra，仅Django 1.10+可用 以上两种结果中日期类型不一样，第一种返回时datetime对象，第二种只返回其中的分类字段，为整数类型。 12345678910111213141516171819# 查询mac地址为`0FFFFFFF561C4030`的设备最近一周每天报警次数。models.Alarm.objects.filter(serial='0FFFFFFF561C4030', create_time__gt=timezone.now()-timedelta(days=7)).extra( select=&#123;'dt': connection.ops.date_trunc_sql('day', 'create_time')&#125;).values('dt').annotate(count=models.Count('create_time')).order_by('dt')[ &#123;'count':4, 'dt':datetime.datetime(2016, 11, 08, 0, 0, 0,0)&#125;, &#123;'count':2, 'dt':datetime.datetime(2016, 11, 11, 0, 0, 0,0)&#125;, &#123;'count':1, 'dt':datetime.datetime(2016, 11, 12, 0, 0, 0,0)&#125;]# 在Django 1.10+ 还可以使用`DateExtra`相关类models.Alarm.objects.filter(serial='0FFFFFFF561C4030', create_time__gt=timezone.now()-timedelta(days=7)) annotate(day=ExtractDay('create_time'))# 结果&#123; 'count':4, 'day': 8, 'count':2, 'day': 11, 'count':1, 'day': 12&#125; 2.3 数据库函数 django.db.models.Q: 与、或、非条件组合查询 django.db.models.F: F()表示数据库中相应字段的值，用于计数器更新等。 django.db.models.Functions.Coalesce:接收一组参数，返回第一个不为None的数据， 更多函数可参考Database Functions。 3 管理器和查询集3.1 管理器与模型的关系管理器是Django数据库查询的接口。查询语法 models.XxModels.objects.filter(*kwargs) 。 一个模型可以拥有一个或多个管理器。 默认情况下，每个模型都有名为objects的管理器，默认返回数据表中所有记录。 管理器来源于默认管理器、外键管理器和自定义管理器。 3.2 自定义管理器当一些查询逻辑复杂而且经常使用时，往往是在管理器上添加自定义函数封装相关查询逻辑，一方面减少重复代码，另一方面对view层透明，有利于MVC职责分工。 自定义管理器有三种方法 3.2.1 继承 models.Manager这是默认出现的方式，以下 period_date函数封装了日期时间段查询函数 1234567891011121314151617181920212223242526272829303132333435class AlarmManager(models.Manager): def period_date(self, field, start_date=None, end_date=None, fmt='%Y-%m-%d'): """封装日期开始结束时间段查询""" def to_datetime(val): if isinstance(val, (datetime, date)): return val else: try: return datetime.strptime(val, fmt) except (TypeError, ValueError): pass kvs = &#123;&#125; start_date = to_datetime(start_date) end_date = to_datetime(end_date) if start_date: kvs[field + '__gte'] = start_date if end_date: kvs[field + '__lte'] = end_date + timedelta(days=1) # 包含当前 return self.filter(**kvs) def has_location(self): return self.filter(longitude__isnull=False, latitude__isnull=False) def unread(self): return self.filter(read=False)# views.py# 返回未读的报警记录alarm_list = models.Alarm.objects.unread()# 返回2016年9月12日到21日的报警记录alarm_list = models.Alarm.objects.period_date(field='create_time', start_time='2016-09-12', end_time='2016-09-21')# 返回2016年9月26日以前的报警记录alarm_list = models.Alarm.objects.period_date(field='create_time', end_time='2016-09-26')#返回2016年9月26日以前的未读报警记录alarm_list = models.Device.objects.period_date(field='create_time', end_time='2016-09-26').unread()AttributeError: '_QuerySet' object has no attribute 'unread' 在最后一个查询中出现异常，因为这两个方法定义在models.Manager上，返回的却是models.QuerySet实例。这时非常希望自定义的方法能够级联调用，下面的几种方法可以解决这个问题。 3.2.2 使用QuerySet的方法使用查询集上的 as_manager()函数创建新的管理器 将自定义的方法定义从models.Manager移到models.QuerySet 123456789101112class AlarmQuerySet(models.QuerySet): def period_date(self, field, start_date=None, end_date=None, fmt='%Y-%m-%d'): # 省略具体代码 pass def has_location(self): return self.filter(longitude__isnull=False, latitude__isnull=False) def unread(self): return self.filter(read=False)class Alarm(models.Model): ... objects = AlarmQuerySet.as_manager() 这时代码alarm_list = models.Device.objects.period_date(field=&#39;create_time&#39;, end_time=&#39;2016-09-26&#39;).unread()就能够返回正确的结果。 3.2.3 继承Manager和QuerySet使用管理器上的from_queryset(queryset_class)函数创建新的管理器在使用django认证用户上一方面需要继承 django.contrib.auth.models.BaseUserManager，另一方面又希望能够自定义函数，这时可以使用这种方式。 123456789101112class UserQuerySet(models.QuerySet): def no_login_in_days(self, days): start_time = timezone.now() - timedelta(days=days) return self.filter(last_login_time__ge=start_time) def no_activity_in_days(self, days): start_time = timezone.now() - timedelta(days=days) return self.filter(last_activity_time__ge=start_time)MyUserManager = BaseUserManager.from_queryset(UserQuerySet)class MyUser(AbstractBaseUser): objects = MyUserManager() 当直接调用django.db.models.Manager.from_queryset方法，其等效于第二种方法，即以下两行等效。 1234# 使用as_manager函数objects = AlarmQuerySet.as_manager()# 使用from_queryset函数objects = models.Manager.from_queryset(AlarmQuerySet) 3.3 managers模块实践随着业务逻辑越来越复杂，需要编写更多的自定义管理器，通常的做法是单独创建一个名称为managers的模块，封装所有数据操作。 1234567891011121314151617181920212223242526from django.db import modelsfrom django.contrib.auth.models import BaseUserManager__all__ = ['AxxManager', 'BxxManager', 'UserManager'] # 外部模块只能引用XxxManager类class BaseQuerySet(models.QuerySet): def common_method_for_all_models(self): passclass AxxQuerySet(BaseQuerySet): passAxxManager = models.Manager().from_queryset(AxxQuerySet)class BxxQuerySet(BaseQuerySet): passBxxManager = models.Manager().from_queryset(BxxQuerySet)class UserQuerySet(BaseQuerySet): passclass UserManager(BaseUserManager.from_queryset(UserQuerySet)): def create_user(self, username, password=None, **kwargs): pass 为避免模块循环导入的问题 需要使用django.apps.apps.get_model函数获取模型类对象，不能直接使用 from models import Xxxx managers模块一般只能被models模块引用，其他模块应当不能引用 3.4 其他覆盖get函数异常 在获取对象函数会抛出ObjectDoesNotExist异常，在这种情况下我们需要使用try-catch捕捉异常，会出现大量重复的代码。这时我们可以用下的代码实现封装。 123456789class BaseManager(models.Manager): def get_object(self, **kwargs): try: return self.get(**kwargs) except models.ObjectDoesNotExist: return None# 以下方式访问device = models.objects.get_object(serial='0FFFFFFF66DDF13F') 访问request变量 按照MVC分离的实践，不应该直接访问request，只能通过参数传递方式。 4 迁移4.1 开发流程迁移是将模型代码的变化应用到数据库，可以认为是一个数据库模式的版本管理系统。 在Django1.7之前的版本第三方库South提供了类似的功能。 迁移通常可以按照下列步骤循环进行。 1 编写 models 模块代码 2 模型迁移：执行 python manage.py makemigrations，在APP.migrations包生成迁移模块文件。 3 数据迁移：如果需要数据迁移，按照一定的格式编写迁移文件。 3 应用迁移：执行 python manage.py migrate，将2、3步迁移文件所实现的数据库变化应用到数据库。 Django Migration分为模式迁移（Schema migration）和数据迁移（Data Migration）。 模式迁移：包括表结构修改，对应于 SQL的 CREATE TABLE ALTER TABLE和 DROP TABLE，可以由Django自动生成。 数据迁移：包括数据记录修改，对应于SQL的 INSERT TO DELETE和 UPDATE等语句,需要开发者自己编写。 无论是模式迁移还是数据迁移，迁移模块都具有几个特点： 每个迁移文件是一个Python模块，位于应用目录migrations包下，代表了一次迁移 每个迁移包含一个名为Migration的迁移类，该类继承自 django.db.migrations.Migration dependencies 属性表示需要依赖的迁移模块名称 operations 属性表示一系列依次进行的迁移操作，这些都定义在 django.db.migrations.operations模块中。 12345from django.db import migrationsclass Migration(migrations.Migration): dependencies = [] operations = [] 4.2 数据迁移下面的例子实现了将设备的longitude latitude和address三个字段复制到报警记录表中，以便查询位置时无需外接操作。 所有的操作被操作 migrations.RunPython 类中，要注意的是需要 django.apps.get_model 函数引用模型类。 1234567891011121314151617181920from __future__ import unicode_literalsfrom django.db import migrations, modelsdef create_address_for_alarm(apps, scheme_editor): AlarmClass = apps.get_model('hdc', 'Alarm') for alarm in AlarmClass.objects.all(): alarm.longitude = alarm.device.longitude alarm.latitude = alarm.device.latitude alarm.address = alarm.device.address alarm.save()class Migration(migrations.Migration): dependencies = [ ('hdc', '0002_alarm_address'), ] operations = [ migrations.RunPython(create_address_for_alarm), ] 5 参考资料 QuerySet API reference | Django documentation | Django Django aggregation, group by day Filtering on annotations in Django Building a higher-level query API: the right way to use Django’s ORM - DabApps, Brighton, UK Django Migrations - A Primer - Real Python Django Custom Model Manager Chaining - Hunter Ford]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Python元类在Django中的Field.choices的应用]]></title>
    <url>%2F2016%2F11%2F02%2Fpython-metaclass%2F</url>
    <content type="text"><![CDATA[使用Python元类改写Django模型字段的choices，使其更加简单可读。 Django Field.choiceschoices是Django定义模型字段的可选参数，适用于所有的字段类型。 choices是一个可迭代的对象，其中每个元素包含两个值。每个元素的第一个元素是写入数据库的真实值，第二个值是可读的名称。类似 n x 2 的二维数组。比如 123456YEAR_IN_SCHOOL_CHOICES = ( (&apos;FR&apos;, &apos;Freshman&apos;), (&apos;SO&apos;, &apos;Sophomore&apos;), (&apos;JR&apos;, &apos;Junior&apos;), (&apos;SR&apos;, &apos;Senior&apos;),) 当某个字段设置了这个参数，默认的表单组件将变成一个携带这些选项的选择框，而不是标准的文本输入框。 一般来说，choices变量应该在model内部定义，而且每个值都用一个常量赋值定义。 123456789101112131415161718192021from django.db import modelsclass Student(models.Model): FRESHMAN = &apos;FR&apos; SOPHOMORE = &apos;SO&apos; JUNIOR = &apos;JR&apos; SENIOR = &apos;SR&apos; YEAR_IN_SCHOOL_CHOICES = ( (FRESHMAN, &apos;Freshman&apos;), (SOPHOMORE, &apos;Sophomore&apos;), (JUNIOR, &apos;Junior&apos;), (SENIOR, &apos;Senior&apos;), ) year_in_school = models.CharField( max_length=2, choices=YEAR_IN_SCHOOL_CHOICES, default=FRESHMAN, ) def is_upperclass(self): return self.year_in_school in (self.JUNIOR, self.SENIOR) 使用方法 12345678&gt;&gt;&gt; s = Student(year_in_school=Student.JUNIOR)&gt;&gt;&gt; s.year_in_school&apos;JR&apos;&gt;&gt;&gt; s.get_year_in_school_display()&apos;Junior&apos;&gt;&gt;&gt; y = &apos;Et&apos;y in [c[0] for c in Student.YEAR_IN_SCHOOL_CHOICES]True 存在的问题 在不考虑多变量同时赋值，每增加一个取值时，需要添加两行代码 由于常量变量（如JUNIOR和SENIOR）直接定义在Model中，当Model有两个字段同时定义了choices，很难区分哪些常量值是属于同一字段的不同取值。 判断取值是否有效时，每次都要构造值的列表 、 集合。 改进后的Field.choices代码如下 12345678910111213141516171819202122232425262728class ChoicesMetaclass(type): def __new__(cls, name, bases, attrs): choices = [] values = &#123;&#125; ks = [] for k, v in six.iteritems(attrs): if k.isupper() and not k.startswith(&apos;_&apos;): if isinstance(v, tuple) and len(v) == 2: pass else: v = v, v ks.append(k) choices.append(v) values[v[0]] = v[1] attrs[k] = v[0] attrs[&apos;choices&apos;] = choices attrs[&apos;values&apos;] = values return type.__new__(cls, name, bases, attrs)class ConstChoices(six.with_metaclass(ChoicesMetaclass)): @classmethod def is_valid(cls, value): return value in cls.values @classmethod def get_value_display(cls, value): return cls.values.get(value) 要点 将同一个choices单独封装在一个类当中。 在定义常量过程中，自动计算choices和values。 每一个项取值都放在一行，如FRESHMAN = &#39;FR&#39;, &#39;Freshman&#39; 使用方法 123456789101112131415class Student(models.Model): class YearInShoolChoices(ConstChoices): FRESHMAN = &apos;FR&apos;, &apos;Freshman&apos; SOPHOMORE = &apos;SO&apos;, &apos;Sophomore&apos; JUNIOR = &apos;JR&apos;, &apos;Junior&apos; SENIOR = &apos;SR&apos;, &apos;Senior&apos; year_in_school = models.CharField( max_length=2, choices=YearInShoolChoices.choices, default=YearInShoolChoices.FRESHMAN, ) def is_upperclass(self): return self.year_in_school in (YearInShoolChoices.JUNIOR, YearInShoolChoices.SENIOR) 使用方法 12345678&gt;&gt;&gt; s = Student(year_in_school=Student.JUNIOR)&gt;&gt;&gt; s.year_in_school&apos;JR&apos;&gt;&gt;&gt; s.get_year_in_school_display()&apos;Junior&apos;&gt;&gt;&gt; y = &apos;Et&apos;YearInShoolChoices.is_valid(y)True]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic安卓构建]]></title>
    <url>%2F2016%2F10%2F29%2Fionic-build-android%2F</url>
    <content type="text"><![CDATA[本文描述了ionic项目构建Android安装包的主要步骤。 1 环境配置1.1 添加Android平台执行 ionic platform add android 即可 1.2 Java路径配置1PATH=path\to\bin\ 1.3 Android环境配置1ANDROID_HOME=你的SDK目录 将 %ANDROID_HOME%\tools\;%ANDROID_HOME%\platform_tools\ 加到PATH变量后面。 2 Android自动签名2.1 配置release-signing.properties文件 在platforms\android目录新建名为release-signing.properties的文件，文件内容如下 1234storeFile=path/to/keystorekeyAlias=your key aliasstorePassword=your store passwordkeyPassword=your key password 备注：在windows下storeFile文件路径应使用Unix下的目录分隔符 /。 3 编译使用 ionic build --release android 编译即可，在\platforms\android\build\outputs\apk出现android-release.apk文件即是已签名的安装包。 4 注意事项在升级到ionic2时，使用 ionic build --release android 可能会出现 ✗ You cannot run iOS unless you are on Mac OSX.的错误，可改为 ionic build android --release 即可。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的起点]]></title>
    <url>%2F2016%2F10%2F28%2Ffirst-post%2F</url>
    <content type="text"><![CDATA[你说有一日总会名扬天下实现你抱负 2016年10月28日，KgBlog重新启用，由之前的 Pelican 改用 hexo 构建，按照官方文档和相关资料将博客基本搭建完成。 当然还有许多事情还没有完成。 继续迁移之前的文章 添加多说评论 添加文章分享 使用自定义域名]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用DaoCloud部署Django项目]]></title>
    <url>%2F2016%2F07%2F23%2Fdaocloud-django-deploy%2F</url>
    <content type="text"><![CDATA[本文介绍了在DaoCloud平台部署Django项目的方法。 1 DaoCloud云平台关于DaoCloud云平台。https://www.daocloud.io/ DaoCloud 为用户提供了 Docker 镜像的自动构建和自动发布功能，当用户完成了 Dockerfile 和 daocloud.yml 文件的编写后，将应用代码推送到第三方代码托管平台上，将其与 DaoCloud 绑定后，在每次修改（commit）后，并将其推送到代码托管平台上，DaoCloud 会检测到代码的变动，并根据 Dockerfile 和 daocloud.yml 进行相应的构建和测试；当触发规定的构建事件（如 tag）时，DaoCloud 会将其进行镜像构建，并推送到相对应的所有生产环节中。 2 Django项目配置项目总布局如下： 123456789101112131415161718192021- wcp_platform/ - admin.py - forms.py - models.py - views.py- wcp/ - daocloud_settings.py - daocloud_wsgi.py - settings.py - test_settings.py - urls.py - wsgi.py- fixtures/ - user.json- static/- template/- Dockerfile- daocloud.yml- docker-entrypoint.sh- manage.py- requirements.txt 3 基于daocloud的配置3.1 daocloud_settings模块daocloud_settings模块重写了数据库配置（这里使用了mysql服务）和wsgi配置模块。 1234567891011121314from __future__ import unicode_literalsfrom .settings import *DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: os.environ[&apos;MYSQL_INSTANCE_NAME&apos;], &apos;USER&apos;: os.environ[&apos;MYSQL_USERNAME&apos;], &apos;PASSWORD&apos;: os.environ[&apos;MYSQL_PASSWORD&apos;], &apos;HOST&apos;: os.environ[&apos;MYSQL_PORT_3306_TCP_ADDR&apos;], &apos;PORT&apos;: os.environ[&apos;MYSQL_PORT_3306_TCP_PORT&apos;], &#125;&#125;WSGI_APPLICATION = wcp.daocloud_wsgi.application&apos; 3.2 daocloud_wsgi模块daocloud_wsgi.py模块设置了环境变量。 12345from __future__ import unicode_literalsimport osfrom django.core.wsgi import get_wsgi_applicationos.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;wcp.daocloud_settings&quot;)application = get_wsgi_application() 3.3 Dockerfile12345678910FROM daocloud.io/python:2.7ADD requirements.txt /tmp/requirements.txtRUN pip install -r /tmp/requirements.txtRUN mkdir /codeWORKDIR /codeCOPY . /codeCOPY docker-entrypoint.sh docker-entrypoint.shRUN chmod +x docker-entrypoint.shEXPOSE 8080CMD /code/docker-entrypoint.sh 具体流程 安装依赖库 拷贝项目代码 修改docker-entrypoint.sh权限为可执行 开放端口 执行docker-entrypoint.sh 3.4 启动脚本123ython /code/manage.py migrate --settings=wcp.daocloud_settings --noinputpython /code/manage.py collectstatic -- settings=wcp.daocloud_settings --noinput/usr/local/bin/gunicorn wcp.daocloud_wsgi:application -w 2 -b :8080 --env DJANGO_SETTINGS_MODULE=&apos;wcp.daocloud_settings&apos; 启动流程 创建数据表 收集静态文件 使用gunicorn启动Django项目 3.5 持续集成：daocloud.yml1234image: daocloud/ci-python:2.7script: - pip install -r requirements.txt - python manage.py test --settings=wcp.test_settings]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>DaoCloud</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动发送动弹到开源中国]]></title>
    <url>%2F2016%2F05%2F17%2Fosc-tweet-publish%2F</url>
    <content type="text"><![CDATA[自动发送动弹到开源中国。 登录系统，密码使用sha1算法加密。 获取用户信息，包括user_code和user_id。 发送动弹。 代码仅在Python3有效。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# coding=utf8from __future__ import unicode_literalsimport hashlibfrom datetime import datetimeimport reimport requestsclass OSCRobot: HEADERS = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.72 Safari/537.36' &#125; def __init__(self, *, username, password, user_code=None, user_id=None): self.username = username self.password = password self.user_code = user_code self.user_id = user_id self.client = requests.session() self.client.headers = self.HEADERS def login(self, **kwargs): if not (self.user_id and self.user_code): self._login(**kwargs) def _login(self, **kwargs): data = &#123; 'email': self.username, 'pwd': hashlib.sha1(self.password.encode('utf8')).hexdigest() &#125; has_login = False login_rsp = self.client.post('https://www.oschina.net/action/user/hash_login', data) if login_rsp.status_code == 200: home_rsp = self.client.get('https://www.oschina.net/') if home_rsp.status_code == 200: text = home_rsp.text m_regx = re.search(r":bind=\"user_code\"\svalue='(?P&lt;user_code&gt;[a-zA-Z0-9]+)'", text) if m_regx: self.user_code = m_regx.group('user_code') m_regx = re.search(r":bind=\"user\"\svalue='(?P&lt;user_id&gt;\d+)'", text) if m_regx: self.user_id = m_regx.group('user_id') has_login = True else: print('[Fail] No user id found!') else: print('[Fail] No user code found!') else: print('[Fail] Request home page fail with status code &#123;&#125;'.format(home_rsp.status_code)) else: print('[Fail] Login fail with status_code &#123;&#125;'.format(login_rsp.status_code)) if has_login: print('[Success] Login success! User info') else: print('[Fail] fail to login!') return has_login def publish_tweet(self, msg, **kwargs): post_data = &#123; 'user_code': self.user_code, 'user': self.user_id, 'msg': msg &#125; rsp = self.client.post('https://www.oschina.net/action/tweet/pub', post_data) if 200 &lt;= rsp.status_code &lt; 300: print('[Success] Push tweet success!') else: print('[Fail] Fail to push tweet!')def main(): robot = OSCRobot( username='YOUR USERNAME', password='YOUR PASSWORD' ) robot.login() robot.publish_tweet('Hello everyone! The current time is &#123;&#125;'.format(datetime.now().strftime('%Y-%m-%d %H:%M:%S')))if __name__ == '__main__': main()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>开源中国</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python打包工具]]></title>
    <url>%2F2016%2F04%2F23%2Fpython-package%2F</url>
    <content type="text"><![CDATA[本文介绍了py2exe、cx_freeze和PyInstaller这三种Python打包工具的使用方法。 1 Python打包工具目前在windows平台上将Python程序打包成exe文件主要有三个工具。 py2exe http://www.py2exe.org/ cx_freeze http://cx-freeze.sourceforge.net/ PyInstaller http://pythonhosted.org/PyInstaller/ 今天将一个Tkinter写的界面程序打包成exe文件，三个工具都试了一遍，感觉PyInstaller会比较好用一些。 2 py2exe2.1 下载安装从这里https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/ 选择python版本和计算机位数对应的exe文件，双击即可安装。 2.2 启动脚本写一个setup_py2exe.py文件 123456789101112from distutils.core import setupimport py2exeoptions = &#123;'py2exe': &#123;'compressed': 1, 'optimize': 2, 'bundle_files': 1, &#125;&#125;setup(name='App', author='kinegratii', version='1.0.0', options=options, windows=[&#123;"script": "app.py"&#125;], zipfile=None ) 2.3 命令执行python setup_py2exe.py py2exe即可，dist目录就是最后生成的结果。 2.4 Q&amp;Aimport py2exe import py2exe这个语句要保留，因为用PyCharm自动格式化的时候总会把这个语句优化掉。 UnicodeDecodeError异常 之前加了from __future__ import unicode_literals这个语句，会报UnicodeDecodeError: &#39;utf8&#39; codec can&#39;t decode byte 0xd1 in position 3: invalid continuation byte lxml库 程序报的异常是ImportError: No module named lxml._elementpath，但按照网上的说法加了includes参数可以解决。 12345options=&#123; 'py2exe': &#123; 'includes': ['lxml.etree', 'lxml._elementpath', 'gzip'], &#125;&#125; TypeError: expected string or buffer 这个异常是docx这个库出现的。找了很久还没有什么头绪。 3 cx_freeze3.1 pip安装执行pip命令即可安装 1pip install cx_Freeze 3.2 启动脚本setup_cx.py文件如下 12345678910111213141516171819from __future__ import unicode_literalsimport sysfrom cx_Freeze import setup, Executablebase = Noneif sys.platform == "win32": base = "Win32GUI"includeFiles = [ (r"D:\py\tcl\tcl8.5", "tcl"), (r"D:\py\tcl\tk8.5", "tk")]setup( name="App", version="1.0", description="A demo app", options=&#123;"build_exe": &#123;"include_files": includeFiles, &#125;&#125;, executables=[Executable("app.py", base=base, includes=['lxml', 'lxml.tree', 'lxml._namepath'])]) 3.3 命令执行命令python setup_cx.py build，dist下的exe.开头的文件夹（名字跟具体环境有关，比如我的是exe.win32-2.7）就是最后的生成的文件夹。 3.4 Q&amp;Alxml 也需要明确包含lxml._elementpath docx 也出现了和py2exe一样的异常。 4 PyInstaller4.1 pip安装执行pip安装 1pip install pyinstaller 安装成功后在python的目录下\Scripts文件夹多出pyinstaller.exe、pyinstaller.exe.manifest、pyinstaller-script.py等几个文件。 4.2 命令方式构建把Scripts目录加到系统的环境变量中，cd到脚本所在的目录，然后执行下面的命令。 1pyinstaller app.py -F -w --clean app.py 脚本文件 几个选项含义 -F 打包为单一文件，和打包为一个文件夹相对，默认为后者 -w 窗口程序，与控制台相对 –clean 每次清理中间产生的构建文件 生成的相关文件包括 app.spec 配置文件 build文件夹 构建中产生的中间文件 dist/app文件夹 这里的文件都是运行所需要的 4.3 启动脚本方式命令行带太多参数的话，每次都要输入，比较麻烦，可以统统写在一个py脚本中。 PyInstaller也是一个标准的Python包，提供了PyInstaller.main.run这个方法。 4.2节中等效的python脚本如下 1234if __name__ == '__main__': from PyInstaller.main import run params=[app.py', '-F', '-w', '--clean'] run(params) 用Python解释器执行这个脚本就可以了。 4.4 Q&amp;Alxml 可以解决lxml包含的问题，无需明确指定 调试 由于用了没有控制台的-w方式，如果程序启动有错的话，只会弹出app return -1的对话框，没有具体异常信息。可以先去掉-w，用控制台进行调试，所有的异常和程序中的print函数就显示在控制台上，方便调试。 单exe资源文件路径问题 这个问题应该只要是最后打包成单个exe都会出现的问题。描述如下 最后打包的文件结构如下 1234- XxxApp - app.exe - data - wpa.db 程序中用下面语句引用wpa.db文件，会出现文件打不开的情况 12BASE_DIR = os.path.abspath(os.path.dirname(__file__))DB_FILE = os.path.join(BASE_DIR,&apos;data&apos;, &apos;wpa.db&apos;) 调试打印出BASE_DIR，发现路径不是XxxApp，而是在用户目录下的某一个位置，类似如下 1c:\Users\kinegratii\AppData&apos;Local\Temp\_MEI11~1\data\wpa.db 这是因为在单文件模式中运行程序的时候先将文件解压到sys._MEIPASS指向的目录下，所以引用资源文件就需要添加os.path.join(sys._MEIPASS,filename)， 第一种方法，具体判断程序当前模式。 1234if getattr(sys, 'frozen', False): BASE_DIR = sys._MEIPASS else: BASE_DIR = os.path.dirname(__file__) 第二种，就是将 __file__ 改为 sys.args[0]，即 1BASE_DIR = os.path.abspath(os.path.dirname(sys.argv[0])) 这样打印的路径就是正确的了，原因在于__file__和sys.args[0]有点区别。 __file__ is the name of the current file, which may be different from the main script if you are inside a module or if you start a script using execfile() rather than by invoking python scriptname.py. __file__ is generally your safer bet. 来自 http://stackoverflow.com/a/5851608 icon图标无法显示问题 使用icon选项即可添加图标，但有时候发现资源管理器的图标可以显示，但运行程序后任务栏上的图标却无法显示。关于这个问题 。 在不同情况下（比如资源管理器文件列表前面的图标、桌面、开始菜单等）需要不一样尺寸的图标。如果尺寸不合适的话，可能出现有的地方显示正确有的显示不正确的情况。最后几个地方都要检查一遍。 解决方案 应该准备四张不同尺寸（具体尺寸参见 http://stackoverflow.com/questions/3236115/which-icon-sizes-should-my-windows-applications-icon-include ）的png文件用png2icon脚本把它们合成一张icon图标文件即可 5 参考资料 py2exe lxml error http://stackoverflow.com/a/5309733 Creating an Executable from a Python Script | Matt Borgersonhttps://mborgerson.com/creating-an-executable-from-a-python-script pyinstaller打包pyqt文件 - dcb3688 - 博客园http://www.cnblogs.com/dcb3688/p/4211390.html 使用pyinstaller打包python程序 - 魏哲的空间https://blog.weizhe.net/?p=412]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytz东八区6分钟问题]]></title>
    <url>%2F2015%2F11%2F12%2Fpython-pytz-6-minutes%2F</url>
    <content type="text"><![CDATA[本文介绍了pytz库中 Asia/Shanghai时区相差6分钟的问题。 之前也一直没有注意到这个问题，最近的项目需要同时显示DTU设备时间和服务器时间，才发现设备时间总是少6-7分钟。在项目中，两者解析成datetime对象的使用方法不一样： 服务器用的是Django框架，使用了django.utils.timezone.now函数解析服务器当前时间 DTU则是自己通过构造函数创建的，时区用的是pytz.timezone(‘Asia/Shanghai’) 首先在一篇文章《用datetime和pytz来转换时区》中说可以用台北时间（Asia/Taipei），试验下发现台北时间也有6分钟的问题。为了测试通过临时强制加上了6分钟，才勉强通过测试，然而这不是长久之计。 晚上下班时回家用“pytz 6分钟”搜索发现了《python中pytz,东8区,6分钟问题 - 老楠老楠》这篇文章。根据文章的描述，用localize函数就可以了。 使用datetime直接构造时间的时候，设置时区是没有北京时间的，一般来说习惯了linux的同志都会默认用上海时间来代替，这里却有一个问题，如果要进行时区转换，上海时间比北京时间差6分钟。。。 比如： 12tz = pytz.timezone(&apos;Asia/Shanghai&apos;)t = datetime.datetime(2015, 9, 5, 9, 0, 0, 0, tzinfo=tz) 这样打印出来得到的时间是： 12015-09-07 09:00:00+08:06 在django框架中，貌似from django.utils.timezone import localtime的这个localtime会修正那6分钟，这问题就来了，要自己在程序里构造时间，并且跟用这个localtime转化的时间对比的时候巨麻烦。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pytz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[djcelery实践]]></title>
    <url>%2F2015%2F10%2F22%2Fdjcelery-practice%2F</url>
    <content type="text"><![CDATA[Celery是一个异步任务队列/基于分布式消息传递的作业队列。Celery通过消息（message）进行通信，使用代理（broker）在客户端和工作执行者之间进行交互。当开始一个任务时，客户端发送消息到队列并由代理将其发往响应的工作执行者处。。djcelery是其和Django框架一个很方便使用的第三方包。 1 环境配置1.1 安装ERLang 首先是到ERLang官网去下载ERlang可执行文件 地址：http://www.erlang.org/download.html 然后安装ERLang。 然后设置ERLang的环境变量。 在环境变量中加入 ERL_HOME = erlang安装目录 在path中添加 %ERL_HOME%\bin 1.2 安装rabbitmq从http://www.rabbitmq.com/releases/rabbitmq-server/v3.1.5/rabbitmq-server-3.1.5.exe下载rabbitmq-server 并安装。 点击开始菜单中的 rabbitmq-start ，rabbitmq-server就启动了，在管理工具-服务中可以看到相关信息的。 1.3 安装Djcelery和大多数Python第三方包一样，用 pip安装celery和djcelery两个包。djcelery依赖于djcelery，所以只要执行pip install djcelery命令即可。 2 配置Djcelery主要步骤 在settings配置相关参数 定义任务 执行任务，可以在程序中调用执行，也可交给后台周期性执行 2.1 基本配置下面是Djcelery的有关配置，定义在Django项目的settings模块内。 12345678910111213141516171819202122232425262728293031323334353637#... ...INSTALLED_APPS = ( 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.sites', 'django.contrib.messages', 'django.contrib.staticfiles', # Uncomment the next line to enable the admin: 'django.contrib.admin', # Uncomment the next line to enable admin documentation: # 'django.contrib.admindocs', 'djcelery', #添加djcelery 'mrs_app', #自己的APP)# ... ....# 配置djcelery相关参数，ResultStore默认存储在数据库可不必重写 ，import djcelerydjcelery.setup_loader()BROKER_URL = 'amqp://guest:guest@localhost:5672//'#任务定义所在的模块CELERY_IMPORTS = ('mrs_app.my_celery.tasks', )# 使用和Django一样的时区CELERY_TIMEZONE = TIME_ZONE#以上为基本配置，以下为周期性任务定义，以celerybeat_开头的 CELERYBEAT_SCHEDULER = 'djcelery.schedulers.DatabaseScheduler'#CELERYBEAT_SCHEDULE = &#123;# 'add-every-3-minutes': &#123;# 'task': 'mrs_app.my_celery.tasks.monthly_reading_task',# 'schedule': timedelta(minutes=3)# &#125;,#&#125; 2.2 定义任务有两种格式 类定义：一个继承了celery.app.task的类并实现了run方法 函数定义：@task装饰的函数 通过实现task相关方法可以实现更多的逻辑，比如成功回调、错误处理、重试机制等，以下是最基本的定义方式。 123456789101112131415161718#mrs_app.my_celery.tasks.pyfrom celery import task```python#第一种，函数方式 @task(name='monthly_reading')def monthly_reading_task(): task_obj = MonthlyReading(debug=False) task_obj.start()#第二种，类定义class MonthlyReadingTask(Task): name='monthly_reading' def run(*args, **kwargs): task_obj = MonthlyReading(debug=False) task_obj.start() 2.3 启动 启动 python manage.py celery worker -l info 如果有定时任务的话，还需要启动心跳 另开一个cmd窗口 python manage.py celery beat （windows下-B选项不可用） 3 执行任务3.1 直接调用自己在代码中的调用，支持延迟/同步/异步调用，可参考task类定义，例子见参考资料的《使用django+celery+RabbitMQ实现异步执行》。 3.2 周期性调用这种由djcelery调用，所以需要在settings.CELERYBEAT_SCHEDULER设置一个调度器，这里使用数据库。 djcelery提供了一些Model（定义在djcelery/models.py文件） 说明： 任务和定时任务的区别：定时任务 = 任务 + intervalschedule/crontabschedule 。两个定时任务可以执行同一个任务。 任务没有相应的Model，用字符串表示，即periodictask模型的task字段 定时任务有相应的Model即periodictask。 djcelery在初始化中主要完成两件： 在settings.CELERY_IMPORTS定义下的模块搜索所有任务。这个对数据库没有任何改变，只是用Admin添加定时任务时periodictask.task字段变成选择框，列出了所有定义的任务。 从settings.CELERYBEAT_SCHEDULE创建定时任务，这个会创建数据记录，相当于celery_models.PeriodicTask.objects.create(..)语句。 3.3 创建定时任务通过它提供的Model Query API来操作，同平常的数据库查询一样。 12345from djcelery import models as celery_modelscelery_models.PeriodicTask.objects.create(...)celery_models.PeriodicTask.ojects.get(name='add').... djcelery提供了admin管理界面，访问http://localhost:8000/admin/djcelery/ 即可，在这里可以对定时任务进行增删改查，具体和Django admin一样。 注：当我们修改任务的设置后，比如关闭、更改时间后不用重启celery服务等。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Celery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python IP归属地查询]]></title>
    <url>%2F2015%2F08%2F30%2Fpython-ip-query%2F</url>
    <content type="text"><![CDATA[基于Python3.2 + tkinter + 淘宝IP API的IP归属地查询。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from tkinter import *import reimport urllibimport urllib.requestimport jsonitem = ('country','area','region','city','isp')itemVar = ('国家','地区','省','市','运营商')class MWindow(Frame): def __init__(self): Frame.__init__(self) self.master.title('IPSearch') self.master.geometry('700x400') self.pack(side = TOP,expand = YES,fill = BOTH) ioPut = &#123;&#125; ioPut['ip_input'] = StringVar() ioPut['result_ouput'] = StringVar() res = &#123;&#125; for vx in item: res[vx] = StringVar() # top Frame topF = self.createFrame(self,TOP) inL = self.createLabel(topF,TOP,'请输入IP地址：') ipE = self.createEntry(topF,TOP,ioPut['ip_input']) resL = self.createLabel(topF,TOP,'查询结果：') resE = self.createEntry(topF,TOP,ioPut['result_ouput']) #mid Frame midF = self.createFrame(self,TOP) i = 0 l = len(item) while i &lt; l: L = self.createLabel(midF,LEFT,itemVar[i]) E = self.createEntry(midF,LEFT,res[item[i]]) i = i + 1 #bottom Frame botF = self.createFrame(self,TOP) searchB = Button(botF,text = 'search', command = lambda ioPut = ioPut,res = res:self.IpSearch(ioPut,res)) searchB.pack(side = TOP,expand = YES,fill = BOTH) def createFrame(self,parent,side): f = Frame(parent) f.pack(side = side,expand = YES,fill = BOTH) return f def createLabel(self,parent,side,text): l = Label(parent,text = text) l.pack(side = side,expand = YES) return l def createEntry(self,parent,side,textvariable): e = Entry(parent,relief = SUNKEN,textvariable = textvariable,width = 15) e.pack(side = side,expand = NO) return e def IpSearch(self,ioPut,res): ipRex = '((?:(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d)))\.)&#123;3&#125;(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d))))' ip = ioPut['ip_input'].get() tmp = re.findall(re.compile(ipRex),ip) if not tmp: ioPut['result_ouput'].set('ip格式错误，请重新输入') return reponseData = IpS().searchByTaobao(ip) data = json.loads(reponseData) if data['code'] == 0: ioPut['result_ouput'].set('该IP所在位置如下') else: ioPut['result_ouput'].set('找不到相关信息') d = data['data'] for vx in item: res[vx].set(d[vx])class IpS(): def __init__(self): self.apiUrlTaobao = 'http://ip.taobao.com/service/getIpInfo.php?ip=' def searchByTaobao(self,ip): headers = ('User-Agent','Mozilla/5.0 (Windows NT 5.1; rv:14.0) Gecko/20100101 Firefox/14.0.1') opener = urllib.request.build_opener() opener.addheaders = [headers] data = opener.open(self.apiUrlTaobao+ip).read() data = data.decode('UTF-8') return dataif __name__ == '__main__': MWindow().mainloop() 效果图]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
